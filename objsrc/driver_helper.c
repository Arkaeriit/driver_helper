/* Generated by Nelua 0.2.0-dev */
/* Compile command: gcc "objsrc/driver_helper.c" -o "objsrc/driver_helper"   -lm */
/* Compile hash: 4H3MJpfStYR8wPpoRR8V3AkcRgVX */
/* ------------------------------ DIRECTIVES -------------------------------- */
#ifdef __GNUC__
  #ifndef __cplusplus
    #pragma GCC diagnostic error   "-Wimplicit-function-declaration"
    #pragma GCC diagnostic error   "-Wimplicit-int"
    #pragma GCC diagnostic ignored "-Wincompatible-pointer-types"
  #else
    #pragma GCC diagnostic ignored "-Wwrite-strings"
    #pragma GCC diagnostic ignored "-Wnarrowing"
  #endif
  #pragma GCC diagnostic ignored "-Wmissing-braces"
  #pragma GCC diagnostic ignored "-Wmissing-field-initializers"
  #pragma GCC diagnostic ignored "-Wtype-limits"
  #pragma GCC diagnostic ignored "-Wunused-parameter"
  #ifdef __clang__
    #pragma GCC diagnostic ignored "-Wunused"
    #pragma GCC diagnostic ignored "-Wparentheses-equality"
  #else
    #pragma GCC diagnostic ignored "-Wunused-value"
    #pragma GCC diagnostic ignored "-Wunused-variable"
    #pragma GCC diagnostic ignored "-Wunused-function"
    #pragma GCC diagnostic ignored "-Wunused-but-set-variable"
    #ifndef __cplusplus
      #pragma GCC diagnostic ignored "-Wdiscarded-qualifiers"
    #endif
  #endif
#endif
#if __STDC_VERSION__ >= 201112L
  #define nelua_static_assert _Static_assert
#elif defined(__cplusplus) && __cplusplus >= 201103L
  #define nelua_static_assert static_assert
#else
  #define nelua_static_assert(x, y)
#endif
nelua_static_assert(sizeof(void*) == 8, "Nelua and C disagree on pointer size");
#include <stdbool.h>
#include <stdint.h>
#if __STDC_VERSION__ >= 201112L
  #define nelua_alignof _Alignof
#elif defined(__cplusplus) && __cplusplus >= 201103L
  #define nelua_alignof alignof
#else
  #define nelua_alignof(x)
#endif
#ifdef __GNUC__
  #define nelua_inline __attribute__((always_inline)) inline
#elif __STDC_VERSION__ >= 199901L
  #define nelua_inline inline
#else
  #define nelua_inline
#endif
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#if __STDC_VERSION__ >= 201112L
  #define nelua_noreturn _Noreturn
#elif defined(__GNUC__)
  #define nelua_noreturn __attribute__((noreturn))
#else
  #define nelua_noreturn
#endif
#ifdef __GNUC__
  #define nelua_likely(x) __builtin_expect(x, 1)
  #define nelua_unlikely(x) __builtin_expect(x, 0)
#else
  #define nelua_likely(x) (x)
  #define nelua_unlikely(x) (x)
#endif
#include <string.h>
#define NLNIL (nlniltype){}
#ifdef __GNUC__
  #define nelua_noinline __attribute__((noinline))
#else
  #define nelua_noinline
#endif
#if defined(__has_feature)
  #if __has_feature(address_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #elif __has_feature(memory_sanitizer)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_memory))
  #endif
#endif
#ifndef NELUA_GC_NO_SANITIZE
  #if defined(__SANITIZE_ADDRESS__)
    #define NELUA_GC_NO_SANITIZE __attribute__((no_sanitize_address))
  #else
    #define NELUA_GC_NO_SANITIZE
  #endif
#endif
#include <setjmp.h>
#include <inttypes.h>
#include <errno.h>
#include <ctype.h>
#include <time.h>
#include <locale.h>
/* ------------------------------ DECLARATIONS ------------------------------ */
typedef struct nlmulret_nlboolean_nlint64_nlpointer {
  bool r1;
  int64_t r2;
  void* r3;
} nlmulret_nlboolean_nlint64_nlpointer;
typedef struct nelua_vector_pointer_ nelua_vector_pointer_;
typedef nelua_vector_pointer_* nelua_vector_pointer__ptr;
typedef struct nelua_span_pointer_ nelua_span_pointer_;
typedef void** nlpointer_arr0_ptr;
struct nelua_span_pointer_ {
  nlpointer_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_pointer_) == 16 && nelua_alignof(nelua_span_pointer_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_GeneralAllocator nelua_GeneralAllocator;
struct nelua_GeneralAllocator {};
struct nelua_vector_pointer_ {
  nelua_span_pointer_ data;
  uintptr_t size;
  nelua_GeneralAllocator allocator;
}; nelua_static_assert(sizeof(nelua_vector_pointer_) == 24 && nelua_alignof(nelua_vector_pointer_) == 8, "Nelua and C disagree on type size or align");
typedef nlmulret_nlboolean_nlint64_nlpointer (*function_3RiL9KEX25TLkt4er)(nelua_vector_pointer__ptr, int64_t);
typedef struct nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64 {
  function_3RiL9KEX25TLkt4er r1;
  nelua_vector_pointer__ptr r2;
  int64_t r3;
} nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64;
static nelua_inline nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64 nelua_ipairs_1(nelua_vector_pointer__ptr a);
static nelua_inline nlmulret_nlboolean_nlint64_nlpointer nelua_ipairs_next(nelua_vector_pointer__ptr a_1, int64_t k);
static nelua_noreturn void nelua_abort();
static nelua_noreturn void nelua_panic_cstring(const char* s);
static nelua_inline void* nelua_assert_deref(void* p);
static nelua_inline uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x);
typedef struct nelua_GCItem nelua_GCItem;
typedef nelua_GCItem* nelua_GCItem_ptr;
typedef void (*nelua_GCFinalizerCallback)(void*, void*);
struct nelua_GCItem {
  uintptr_t flags;
  uintptr_t size;
  void* ptr;
  nelua_GCFinalizerCallback finalizer;
  void* userdata;
}; nelua_static_assert(sizeof(nelua_GCItem) == 40 && nelua_alignof(nelua_GCItem) == 8, "Nelua and C disagree on type size or align");
typedef struct nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr {
  bool r1;
  void* r2;
  nelua_GCItem_ptr r3;
} nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr;
typedef struct nelua_hashmap_iteratorT nelua_hashmap_iteratorT;
typedef nelua_hashmap_iteratorT* nelua_hashmap_iteratorT_ptr;
typedef struct nelua_hashmap_pointer__GCItem_ nelua_hashmap_pointer__GCItem_;
typedef nelua_hashmap_pointer__GCItem_* nelua_hashmap_pointer__GCItem__ptr;
typedef struct nelua_span_usize_ nelua_span_usize_;
typedef uintptr_t* nlusize_arr0_ptr;
struct nelua_span_usize_ {
  nlusize_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_usize_) == 16 && nelua_alignof(nelua_span_usize_) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_hashmapnode_pointer__GCItem__ nelua_span_hashmapnode_pointer__GCItem__;
typedef struct nelua_hashmapnode_pointer__GCItem_ nelua_hashmapnode_pointer__GCItem_;
struct nelua_hashmapnode_pointer__GCItem_ {
  void* key;
  nelua_GCItem value;
  bool filled;
  uintptr_t next;
}; nelua_static_assert(sizeof(nelua_hashmapnode_pointer__GCItem_) == 64 && nelua_alignof(nelua_hashmapnode_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__arr0_ptr;
struct nelua_span_hashmapnode_pointer__GCItem__ {
  nelua_hashmapnode_pointer__GCItem__arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_hashmapnode_pointer__GCItem__) == 16 && nelua_alignof(nelua_span_hashmapnode_pointer__GCItem__) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_pointer__GCItem_ {
  nelua_span_usize_ buckets;
  nelua_span_hashmapnode_pointer__GCItem__ nodes;
  uintptr_t size;
  uintptr_t free_index;
  nelua_GeneralAllocator allocator;
}; nelua_static_assert(sizeof(nelua_hashmap_pointer__GCItem_) == 48 && nelua_alignof(nelua_hashmap_pointer__GCItem_) == 8, "Nelua and C disagree on type size or align");
struct nelua_hashmap_iteratorT {
  nelua_hashmap_pointer__GCItem__ptr container;
  uintptr_t index;
}; nelua_static_assert(sizeof(nelua_hashmap_iteratorT) == 16 && nelua_alignof(nelua_hashmap_iteratorT) == 8, "Nelua and C disagree on type size or align");
typedef nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr (*function_5CJP53TT7B2LA277q)(nelua_hashmap_iteratorT_ptr, void*);
typedef struct nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer {
  function_5CJP53TT7B2LA277q r1;
  nelua_hashmap_iteratorT r2;
  void* r3;
} nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer;
static nelua_inline nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a);
typedef struct nelua_span_uint8_ nelua_span_uint8_;
typedef nelua_span_uint8_* nelua_span_uint8__ptr;
typedef uint8_t* nluint8_arr0_ptr;
struct nelua_span_uint8_ {
  nluint8_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_uint8_) == 16 && nelua_alignof(nelua_span_uint8_) == 8, "Nelua and C disagree on type size or align");
static nelua_inline bool nelua_span_uint8__empty(nelua_span_uint8__ptr self);
typedef uint8_t* nluint8_ptr;
static nelua_inline nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i);
typedef struct nlstring nlstring;
struct nlstring {
  nluint8_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nlstring) == 16 && nelua_alignof(nlstring) == 8, "Nelua and C disagree on type size or align");
static void nelua_assert_line_1(bool cond, nlstring msg);
typedef void** nlpointer_ptr;
typedef nelua_span_pointer_* nelua_span_pointer__ptr;
static nelua_inline nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i);
static void nelua_assert_line_2(bool cond, nlstring msg);
typedef uintptr_t* nlusize_ptr;
typedef nelua_span_usize_* nelua_span_usize__ptr;
static nelua_inline nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i);
static void nelua_assert_line_3(bool cond, nlstring msg);
typedef nelua_hashmapnode_pointer__GCItem_* nelua_hashmapnode_pointer__GCItem__ptr;
typedef nelua_span_hashmapnode_pointer__GCItem__* nelua_span_hashmapnode_pointer__GCItem___ptr;
static nelua_inline nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i);
static void nelua_assert_line_4(bool cond, nlstring msg);
typedef nlstring* nlstring_ptr;
typedef struct nelua_span_string_ nelua_span_string_;
typedef nelua_span_string_* nelua_span_string__ptr;
typedef nlstring* nlstring_arr0_ptr;
struct nelua_span_string_ {
  nlstring_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_string_) == 16 && nelua_alignof(nelua_span_string_) == 8, "Nelua and C disagree on type size or align");
static nelua_inline nlstring_ptr nelua_span_string____atindex(nelua_span_string__ptr self, uintptr_t i);
static void nelua_assert_line_5(bool cond, nlstring msg);
typedef struct parser_pure_line parser_pure_line;
typedef parser_pure_line* parser_pure_line_ptr;
struct parser_pure_line {
  int64_t len;
  nlstring content[50];
}; nelua_static_assert(sizeof(parser_pure_line) == 808 && nelua_alignof(parser_pure_line) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_pure_line_ nelua_span_pure_line_;
typedef nelua_span_pure_line_* nelua_span_pure_line__ptr;
typedef parser_pure_line* parser_pure_line_arr0_ptr;
struct nelua_span_pure_line_ {
  parser_pure_line_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_pure_line_) == 16 && nelua_alignof(nelua_span_pure_line_) == 8, "Nelua and C disagree on type size or align");
static nelua_inline parser_pure_line_ptr nelua_span_pure_line____atindex(nelua_span_pure_line__ptr self, uintptr_t i);
static void nelua_assert_line_6(bool cond, nlstring msg);
typedef struct driver_helper_line_content driver_helper_line_content;
typedef driver_helper_line_content* driver_helper_line_content_ptr;
struct driver_helper_line_content {
  nlstring name;
  int64_t address;
  int64_t offset;
  int64_t size;
}; nelua_static_assert(sizeof(driver_helper_line_content) == 40 && nelua_alignof(driver_helper_line_content) == 8, "Nelua and C disagree on type size or align");
typedef struct nelua_span_line_content_ nelua_span_line_content_;
typedef nelua_span_line_content_* nelua_span_line_content__ptr;
typedef driver_helper_line_content* driver_helper_line_content_arr0_ptr;
struct nelua_span_line_content_ {
  driver_helper_line_content_arr0_ptr data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_span_line_content_) == 16 && nelua_alignof(nelua_span_line_content_) == 8, "Nelua and C disagree on type size or align");
static nelua_inline driver_helper_line_content_ptr nelua_span_line_content____atindex(nelua_span_line_content__ptr self, uintptr_t i);
static void nelua_assert_line_7(bool cond, nlstring msg);
static nelua_inline void nelua_memory_copy(void* dest, void* src, uintptr_t n);
static void nelua_assert_line_8(bool cond, nlstring msg);
static nelua_inline void nelua_memory_set(void* dest, uint8_t x, uintptr_t n);
static void nelua_assert_line_9(bool cond, nlstring msg);
static nelua_inline bool nelua_memory_equals(void* a, void* b, uintptr_t size);
static void nelua_assert_line_10(bool cond, nlstring msg);
static nelua_inline void* nelua_memory_scan(void* src, uint8_t x, uintptr_t size);
static void nelua_assert_line_11(bool cond, nlstring msg);
static nelua_inline void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x);
static nelua_inline bool nelua_isdigit(uint8_t x);
typedef struct {uint8_t v[32];} nluint8_arr32; nelua_static_assert(sizeof(nluint8_arr32) == 32 && nelua_alignof(nluint8_arr32) == 1, "Nelua and C disagree on type size or align");
typedef nluint8_arr32* nluint8_arr32_ptr;
static uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form);
static void nelua_assert_line_12(bool cond, nlstring msg);
static void nelua_assert_line_13(bool cond, nlstring msg);
static nelua_inline uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len);
static void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize);
static nelua_inline size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x);
static nelua_inline size_t nelua_assert_bounds_nlcsize(size_t index, uintptr_t len);
static nelua_GeneralAllocator nelua_general_allocator;
typedef nelua_GeneralAllocator* nelua_GeneralAllocator_ptr;
static nelua_inline void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static nelua_inline void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p);
static nelua_inline void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void* nelua_GeneralAllocator_xalloc0(nelua_GeneralAllocator_ptr self, uintptr_t size);
static void nelua_assert_line_14(bool cond, nlstring msg);
static void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
typedef struct nlniltype {} nlniltype;
static nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size);
static void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s);
static void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s);
static void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s);
static nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static nelua_span_string_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size);
static void nelua_assert_line_15(bool cond, nlstring msg);
static nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size);
static void nelua_assert_line_16(bool cond, nlstring msg);
static nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size);
static void nelua_assert_line_17(bool cond, nlstring msg);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size);
static void nelua_assert_line_18(bool cond, nlstring msg);
typedef struct nelua_sequenceimpl_string__1 nelua_sequenceimpl_string__1;
typedef nelua_sequenceimpl_string__1* nelua_sequenceimpl_string__1_ptr;
struct nelua_sequenceimpl_string__1 {
  nelua_span_string_ data;
  uintptr_t size;
}; nelua_static_assert(sizeof(nelua_sequenceimpl_string__1) == 24 && nelua_alignof(nelua_sequenceimpl_string__1) == 8, "Nelua and C disagree on type size or align");
static nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size);
static uintptr_t nelua_hash_hash_1(void* v);
static nelua_inline uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y);
static nelua_inline uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n);
static nelua_inline uintptr_t nelua_roundpow2(uintptr_t n);
static void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self);
typedef struct nlmulret_nlusize_nlusize_nlusize {
  uintptr_t r1;
  uintptr_t r2;
  uintptr_t r3;
} nlmulret_nlusize_nlusize_nlusize;
static nelua_inline nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_noinline void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count);
static void nelua_assert_line_19(bool cond);
static uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static void nelua_assert_line_20(bool cond, nlstring msg);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key);
static double nelua_hashmap_pointer__GCItem__loadfactor(nelua_hashmap_pointer__GCItem__ptr self);
static nelua_inline nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key);
static nelua_inline nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self);
static void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self);
static nelua_noinline void nelua_vectorT_grow(nelua_vector_pointer__ptr self);
static void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v);
static nelua_inline nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t i);
static void nelua_assert_line_21(bool cond, nlstring msg);
static nelua_inline intptr_t nelua_vector_pointer____len(nelua_vector_pointer__ptr self);
typedef struct nelua_vector_pure_line_ nelua_vector_pure_line_;
typedef nelua_vector_pure_line_* nelua_vector_pure_line__ptr;
typedef struct nelua_GCAllocator nelua_GCAllocator;
struct nelua_GCAllocator {};
struct nelua_vector_pure_line_ {
  nelua_span_pure_line_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
}; nelua_static_assert(sizeof(nelua_vector_pure_line_) == 24 && nelua_alignof(nelua_vector_pure_line_) == 8, "Nelua and C disagree on type size or align");
static nelua_noinline void nelua_vectorT_grow_1(nelua_vector_pure_line__ptr self);
static void nelua_vector_pure_line__push(nelua_vector_pure_line__ptr self, parser_pure_line v);
static nelua_inline parser_pure_line_ptr nelua_vector_pure_line____atindex(nelua_vector_pure_line__ptr self, uintptr_t i);
static void nelua_assert_line_22(bool cond, nlstring msg);
static nelua_inline intptr_t nelua_vector_pure_line____len(nelua_vector_pure_line__ptr self);
typedef struct nelua_vector_line_content_ nelua_vector_line_content_;
typedef nelua_vector_line_content_* nelua_vector_line_content__ptr;
struct nelua_vector_line_content_ {
  nelua_span_line_content_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
}; nelua_static_assert(sizeof(nelua_vector_line_content_) == 24 && nelua_alignof(nelua_vector_line_content_) == 8, "Nelua and C disagree on type size or align");
static nelua_noinline void nelua_vectorT_grow_2(nelua_vector_line_content__ptr self);
static void nelua_vector_line_content__push(nelua_vector_line_content__ptr self, driver_helper_line_content v);
static nelua_inline driver_helper_line_content_ptr nelua_vector_line_content____atindex(nelua_vector_line_content__ptr self, uintptr_t i);
static void nelua_assert_line_23(bool cond, nlstring msg);
static nelua_inline intptr_t nelua_vector_line_content____len(nelua_vector_line_content__ptr self);
static nelua_inline bool nelua_hasflag(uintptr_t flags, uintptr_t flag);
static nelua_inline bool nelua_GCItem_ismarked(nelua_GCItem_ptr self);
typedef struct nelua_GC nelua_GC;
struct nelua_GC {
  bool running;
  bool collecting;
  uintptr_t pause;
  uintptr_t membytes;
  uintptr_t lastmembytes;
  uintptr_t minaddr;
  uintptr_t maxaddr;
  void* stackbottom;
  nelua_vector_pointer_ frees;
  nelua_hashmap_pointer__GCItem_ items;
}; nelua_static_assert(sizeof(nelua_GC) == 128 && nelua_alignof(nelua_GC) == 8, "Nelua and C disagree on type size or align");
static nelua_GC nelua_gc;
typedef nelua_GC* nelua_GC_ptr;
static bool nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize);
static NELUA_GC_NO_SANITIZE void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high);
static nelua_noinline void nelua_GC_unmarkall(nelua_GC_ptr self);
static nelua_noinline void nelua_GC_markroot(nelua_GC_ptr self);
static nelua_noinline void nelua_GC_markstackinner(nelua_GC_ptr self);
static nelua_noinline void nelua_GC_markstack(nelua_GC_ptr self);
typedef void (*function_4gqRYyaV7UKZhzZGK)(nelua_GC_ptr);
static void nelua_GC_mark(nelua_GC_ptr self);
static nelua_noinline void nelua_GC_sweep(nelua_GC_ptr self);
static void nelua_assert_line_24(bool cond, nlstring msg);
static void nelua_assert_line_25(bool cond, nlstring msg);
static void nelua_GC_collect(nelua_GC_ptr self);
static void nelua_GC_registerroots(nelua_GC_ptr self);
typedef void (*function_2wTCtLbGnp96MYzKT)(void*, void*);
static void nelua_GC_maybecollect(nelua_GC_ptr self);
static void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2wTCtLbGnp96MYzKT finalizer, void* userdata);
static void nelua_assert_line_26(bool cond, nlstring msg);
static bool nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize);
static void nelua_assert_line_27(bool cond, nlstring msg);
static void nelua_GC_restart(nelua_GC_ptr self);
static void nelua_GC_init(nelua_GC_ptr self, void* stack);
static void nelua_GC_destroy(nelua_GC_ptr self);
typedef char** nlcstring_ptr;
int main(int argc, nlcstring_ptr argv);
typedef int (*function_3a75JJwhuWwoVVKzM)(int, nlcstring_ptr);
static nelua_GCAllocator nelua_gc_allocator;
typedef nelua_GCAllocator* nelua_GCAllocator_ptr;
static nelua_noinline void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_noinline void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static nelua_noinline void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata);
static nelua_noinline void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr);
static nelua_noinline void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize);
static nelua_span_pure_line_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_line_content_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
static nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata);
typedef struct nelua_FStream nelua_FStream;
typedef nelua_FStream* nelua_FStream_ptr;
typedef FILE* FILE_ptr;
typedef int (*function_58d7Pdou2YVLfzmgT)(FILE_ptr);
struct nelua_FStream {
  FILE_ptr fp;
  function_58d7Pdou2YVLfzmgT closef;
}; nelua_static_assert(sizeof(nelua_FStream) == 16 && nelua_alignof(nelua_FStream) == 8, "Nelua and C disagree on type size or align");
static nelua_noinline nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size);
static void nelua_assert_line_28(bool cond, nlstring msg);
static void* nelua_GCAllocator_xalloc(nelua_GCAllocator_ptr self, uintptr_t size);
static void nelua_assert_line_29(bool cond, nlstring msg);
static void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize);
static void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static nelua_span_pure_line_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size);
static nelua_span_line_content_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_line_content_ s, uintptr_t size);
static nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
static void nelua_assert_line_30(bool cond, nlstring msg);
static nelua_span_pure_line_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size);
static void nelua_assert_line_31(bool cond, nlstring msg);
static nelua_span_line_content_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_line_content_ s, uintptr_t size);
static void nelua_assert_line_32(bool cond, nlstring msg);
static nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size);
typedef struct nelua_stringbuilderT nelua_stringbuilderT;
typedef nelua_stringbuilderT* nelua_stringbuilderT_ptr;
struct nelua_stringbuilderT {
  nelua_span_uint8_ data;
  uintptr_t size;
  nelua_GCAllocator allocator;
}; nelua_static_assert(sizeof(nelua_stringbuilderT) == 24 && nelua_alignof(nelua_stringbuilderT) == 8, "Nelua and C disagree on type size or align");
static void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self);
static bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize);
static nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n);
static void nelua_assert_line_33(bool cond, nlstring msg);
static bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n);
typedef struct nlmulret_nlboolean_nlusize {
  bool r1;
  uintptr_t r2;
} nlmulret_nlboolean_nlusize;
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1);
typedef struct nlmulret_nlboolean_nlcint {
  bool r1;
  int r2;
} nlmulret_nlboolean_nlcint;
static nlmulret_nlboolean_nlcint nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, int64_t arg1);
static nelua_inline int nelua_assert_narrow_nlusize_nlcint(uintptr_t x);
static void nelua_assert_line_34(bool cond, nlstring msg);
static void nelua_assert_line_35(bool cond, nlstring msg);
static nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, int64_t __arg1);
static void nelua_assert_line_36(bool cond, nlstring msg);
static nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self);
typedef struct nelua_sequence_string__1 nelua_sequence_string__1;
typedef nelua_sequence_string__1* nelua_sequence_string__1_ptr;
struct nelua_sequence_string__1 {
  nelua_sequenceimpl_string__1_ptr impl;
  nelua_GeneralAllocator allocator;
}; nelua_static_assert(sizeof(nelua_sequence_string__1) == 8 && nelua_alignof(nelua_sequence_string__1) == 8, "Nelua and C disagree on type size or align");
static void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self);
static void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n);
static nelua_noinline void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self);
static nelua_inline nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t i);
static void nelua_assert_line_37(bool cond, nlstring msg);
static nelua_inline intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self);
static nlstring nelua_nlstring_create(uintptr_t size);
static void nelua_assert_line_38(bool cond, nlstring msg);
static void nelua_nlstring_destroy(nlstring_ptr self);
static nlstring nelua_nlstring_copy(nlstring s);
static uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i);
static void nelua_assert_line_39(bool cond, nlstring msg);
static nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j);
static nlstring nelua_nlstring_lower(nlstring s);
static nlstring nelua_nlstring_format_2(nlstring fmt, int64_t __arg1);
static nelua_inline intptr_t nelua_nlstring___len(nlstring a);
static bool nelua_nlstring___eq(nlstring a, nlstring b);
static int64_t nelua_str2intbase(nlstring s, uint64_t base);
static void nelua_assert_line_40(bool cond, nlstring msg);
static void nelua_assert_line_41(bool cond, nlstring msg);
static void nelua_assert_line_42(bool cond, nlstring msg);
static void nelua_assert_line_43(bool cond, nlstring msg);
static void nelua_assert_line_44(bool cond, nlstring msg);
static nlstring nelua_tostring_1(intptr_t x);
typedef struct {uint8_t v[48];} nluint8_arr48; nelua_static_assert(sizeof(nluint8_arr48) == 48 && nelua_alignof(nluint8_arr48) == 1, "Nelua and C disagree on type size or align");
static void nelua_assert_line_45(bool cond, nlstring msg);
static nelua_inline uintptr_t nelua_assert_narrow_nlcint_nlusize(int x);
static nlstring nelua_tostring_2(int64_t x);
static void nelua_assert_line_46(bool cond, nlstring msg);
static int64_t nelua_tointeger_1(nlstring x, int64_t base);
static nelua_inline uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x);
typedef struct nlmulret_nlboolean_nlstring_nlint64 {
  bool r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlboolean_nlstring_nlint64;
static nlmulret_nlboolean_nlstring_nlint64 nelua_fileresult(bool success);
static nelua_inline nlstring nelua_cstring2string(const char* s);
typedef struct nelua_filestream nelua_filestream;
struct nelua_filestream {
  nelua_FStream_ptr fs;
}; nelua_static_assert(sizeof(nelua_filestream) == 8 && nelua_alignof(nelua_filestream) == 8, "Nelua and C disagree on type size or align");
typedef int (*function_5Ch8aJn9o3Dod1HWE)(FILE_ptr);
static nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_5Ch8aJn9o3Dod1HWE closef);
typedef nelua_filestream* nelua_filestream_ptr;
static nelua_inline FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self);
static bool nelua_checkmode(nlstring mode);
typedef struct nlmulret_nelua_filestream_nlstring_nlint64 {
  nelua_filestream r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nelua_filestream_nlstring_nlint64;
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlstring mode);
static void nelua_assert_line_47(bool cond, nlstring msg);
static nelua_inline char* nelua_assert_string2cstring(nlstring s);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self);
typedef struct nlmulret_nlboolean_nlstring {
  bool r1;
  nlstring r2;
} nlmulret_nlboolean_nlstring;
static nlmulret_nlboolean_nlstring nelua_readline(nelua_stringbuilderT_ptr sb, FILE_ptr fp, bool chop);
static nelua_inline bool nelua_eq_nlcint_nluint8(int a, uint8_t b);
static nlmulret_nlboolean_nlstring nelua_readall(nelua_stringbuilderT_ptr sb, FILE_ptr fp);
typedef struct nlmulret_nlstring_nlstring_nlint64 {
  nlstring r1;
  nlstring r2;
  int64_t r3;
} nlmulret_nlstring_nlstring_nlint64;
static nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, nlstring fmt);
static nelua_noreturn void nelua_panic_string(nlstring s);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3);
static nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_3(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2);
static nelua_FStream nelua_stderrfs;
static nelua_FStream nelua_stdoutfs;
static nelua_FStream nelua_stdinfs;
static nelua_filestream nelua_io_stderr;
static nelua_filestream nelua_io_stdout;
static nelua_filestream nelua_io_stdin;
static nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlstring mode);
static nelua_noreturn void nelua_os_exit_1(int64_t code);
static nelua_inline int nelua_assert_narrow_nlint64_nlcint(int64_t x);
static nelua_sequence_string__1 nelua_arg;
static nelua_inline uint64_t nelua_rotl(uint64_t x, int32_t n);
static nelua_inline uint64_t nelua_shl_nluint64(uint64_t a, int64_t b);
static nelua_inline uint64_t nelua_shr_nluint64(uint64_t a, int64_t b);
typedef struct nelua_Xoshiro256 nelua_Xoshiro256;
typedef nelua_Xoshiro256* nelua_Xoshiro256_ptr;
struct nelua_Xoshiro256 {
  uint64_t state[4];
}; nelua_static_assert(sizeof(nelua_Xoshiro256) == 32 && nelua_alignof(nelua_Xoshiro256) == 8, "Nelua and C disagree on type size or align");
static uint64_t nelua_Xoshiro256_nextrand(nelua_Xoshiro256_ptr self);
typedef struct {uint64_t v[4];} nluint64_arr4; nelua_static_assert(sizeof(nluint64_arr4) == 32 && nelua_alignof(nluint64_arr4) == 8, "Nelua and C disagree on type size or align");
static double nelua_Xoshiro256_random(nelua_Xoshiro256_ptr self);
static void nelua_Xoshiro256_seed(nelua_Xoshiro256_ptr self, uint64_t a, uint64_t b);
static nelua_Xoshiro256 nelua_default_random = {.state = {0x65ce039baebe74b4U, 0x4911ada153b51eefU, 0xfb71fbb497c00950U, 0xf83ccf6ac1b74755U}};
typedef struct nlmulret_nlint64_nlint64 {
  int64_t r1;
  int64_t r2;
} nlmulret_nlint64_nlint64;
static nlmulret_nlint64_nlint64 nelua_math_randomseed_1(nlniltype x, nlniltype y);
typedef time_t* time_t_ptr;
static int64_t nelua_math_random_1(int64_t m, int64_t n);
static void nelua_assert_line_48(bool cond, nlstring msg);
static void nelua_assert_line_49(bool cond, nlstring msg);
static void nelua_assert_line_50(bool cond, nlstring msg);
static int64_t parser_pure_line___len(parser_pure_line_ptr self);
static nlstring parser_pure_line___index(parser_pure_line_ptr self, int64_t i);
typedef struct {nlstring v[50];} nlstring_arr50; nelua_static_assert(sizeof(nlstring_arr50) == 800 && nelua_alignof(nlstring_arr50) == 8, "Nelua and C disagree on type size or align");
static nelua_inline int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len);
typedef struct parser_pure_file parser_pure_file;
typedef parser_pure_file* parser_pure_file_ptr;
struct parser_pure_file {
  nelua_vector_pure_line_ content;
}; nelua_static_assert(sizeof(parser_pure_file) == 24 && nelua_alignof(parser_pure_file) == 8, "Nelua and C disagree on type size or align");
static intptr_t parser_pure_file___len(parser_pure_file_ptr self);
static parser_pure_line parser_pure_file___index(parser_pure_file_ptr self, int64_t i);
static bool parser_is_whitespace_or_coma(nlstring s);
static parser_pure_line parser_purify_line(nlstring s);
static parser_pure_file parser_purify_string(nlstring s);
static parser_pure_file parser_purify_file(nelua_filestream file);
typedef int64_t driver_helper_error_t;
typedef struct nlmulret_nelua_vector_line_content__driver_helper_error_t {
  nelua_vector_line_content_ r1;
  driver_helper_error_t r2;
} nlmulret_nelua_vector_line_content__driver_helper_error_t;
static nlmulret_nelua_vector_line_content__driver_helper_error_t driver_helper_decode_input(parser_pure_file input);
static nlstring driver_helper_format_field(driver_helper_line_content field);
static nlstring driver_helper_add_include_guard(nlstring header);
static nlstring driver_helper_make_header(nelua_vector_line_content_ csv);
static char nelua_strlit_1[694] = "// -------------------- User-defined functions to edit registers ------------ //\n\n#include \"stdint.h\"\n\n// Replace here with the type used to represent the content of the registers\n// and their address.\ntypedef uint8_t _driver_helper_t;\n\n// Replace here with a function _register_read(addr) that reads the\n// register at address `addr`\nstatic _driver_helper_t _register_read(_driver_helper_t addr) {\n    return 0;\n}\n\n// Replace here with a function _register_write(addr, data) that write `data`\n// to the register at address `addr`\nstatic void _register_write(_driver_helper_t addr, _driver_helper_t data) {\n}\n\n\n// -------------------------- Info about all the fields --------------------- //\n\n";
static nelua_inline uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x);
static char nelua_strlit_2[1298] = "// --------------------- Macro used to manipulate fields -------------------- //\n\nstatic _driver_helper_t _driver_helper_size_mask(uint8_t size) {\n    return (1 << size) - 1;\n}\n\nstatic _driver_helper_t _driver_helper_field_read(_driver_helper_t addr, uint8_t size, uint8_t offset) {\n    return (_register_read(addr) >> offset) & _driver_helper_size_mask(size);\n}\n\n#define FIELD_READ(field_name) \\\n    _driver_helper_field_read(field_name ## _ADDR, field_name ## _SIZE, field_name ## _OFFSET)\n\nstatic _driver_helper_t _driver_helper_pos_mask(uint8_t size, uint8_t offset) {\n    return ~(_driver_helper_size_mask(size) << offset);\n}\n\nstatic void _driver_helper_field_write(_driver_helper_t addr, uint8_t size, uint8_t offset, _driver_helper_t data) {\n    _driver_helper_t rest_of_the_reg = _register_read(addr) & _driver_helper_pos_mask(size, offset);\n    _driver_helper_t updated_reg = rest_of_the_reg | (data << offset);\n    _register_write(addr, updated_reg);\n}\n\n#define FIELD_WRITE(field_name, data) \\\n    _driver_helper_field_write(field_name ## _ADDR, field_name ## _SIZE, field_name ## _OFFSET, data)\n\n\n/*-------------------------------------------\\\n|  Header file generated with driver-helper  |\n| https://github.com/Arkaeriit/driver_helper |\n\\-------------------------------------------*/\n\n";
static int64_t driver_helper_main();
static void nelua_print_1(nlstring a1);
static char nelua_strlit_3[338] = "driver-helper, a tool to help you write drivers for devices.\n\nThis tools takes as input a CSV file presenting each fields of each\nregisters of the device and generates a C header file with macros\nused to manipulate those fields.\n\nUsage: driver-helper <input CSV> <output header>\n\nMore info at https://github.com/Arkaeriit/driver_helper.\n";
static int nelua_main(int nelua_argc, char** nelua_argv);
/* ------------------------------ DEFINITIONS ------------------------------- */
void nelua_abort(){
  fflush(stderr);
  abort();
}
void nelua_panic_cstring(const char* s){
  fputs(s, stderr);
  fputc('\n', stderr);
  nelua_abort();
}
void* nelua_assert_deref(void* p){
  if(nelua_unlikely(p == NULL)) {
    nelua_panic_cstring("attempt to dereference a null pointer");
  }
  return p;
}
uintptr_t nelua_assert_narrow_nlint64_nlusize(int64_t x){
  if(nelua_unlikely(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to usize failed");
  }
  return x;
}
nlmulret_nlboolean_nlint64_nlpointer nelua_ipairs_next(nelua_vector_pointer__ptr a_1, int64_t k) {
  k = (k + 1);
  if((k >= (nelua_vector_pointer____len(a_1) + 0))) {
    return (nlmulret_nlboolean_nlint64_nlpointer){false, 0, NULL};
  }
  return (nlmulret_nlboolean_nlint64_nlpointer){true, k, (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex(a_1, nelua_assert_narrow_nlint64_nlusize(k))))};
}
nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64 nelua_ipairs_1(nelua_vector_pointer__ptr a) {
  return (nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64){nelua_ipairs_next, a, -1};
}
nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer nelua_mpairs_1(nelua_hashmap_pointer__GCItem__ptr a) {
  nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer _ret_1 = nelua_hashmap_pointer__GCItem____mpairs(a);
  return (nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer){_ret_1.r1, _ret_1.r2, _ret_1.r3};
}
bool nelua_span_uint8__empty(nelua_span_uint8__ptr self) {
  return (self->size == 0);
}
void nelua_assert_line_1(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
nluint8_ptr nelua_span_uint8____atindex(nelua_span_uint8__ptr self, uintptr_t i) {
  nelua_assert_line_1((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_2(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
nlpointer_ptr nelua_span_pointer____atindex(nelua_span_pointer__ptr self, uintptr_t i) {
  nelua_assert_line_2((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_3(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
nlusize_ptr nelua_span_usize____atindex(nelua_span_usize__ptr self, uintptr_t i) {
  nelua_assert_line_3((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_4(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
nelua_hashmapnode_pointer__GCItem__ptr nelua_span_hashmapnode_pointer__GCItem_____atindex(nelua_span_hashmapnode_pointer__GCItem___ptr self, uintptr_t i) {
  nelua_assert_line_4((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_5(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
nlstring_ptr nelua_span_string____atindex(nelua_span_string__ptr self, uintptr_t i) {
  nelua_assert_line_5((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_6(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
parser_pure_line_ptr nelua_span_pure_line____atindex(nelua_span_pure_line__ptr self, uintptr_t i) {
  nelua_assert_line_6((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_7(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/span.nelua\033[1m:78:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 79, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'index out of range')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 98, stderr);
    nelua_abort();
  }
}
driver_helper_line_content_ptr nelua_span_line_content____atindex(nelua_span_line_content__ptr self, uintptr_t i) {
  nelua_assert_line_7((i < self->size), ((nlstring){(uint8_t*)"index out of range", 18}));
  return (&self->data[i]);
}
void nelua_assert_line_8(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:25:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(dest and src, 'invalid pointer')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 89, stderr);
    nelua_abort();
  }
}
void nelua_memory_copy(void* dest, void* src, uintptr_t n) {
  nelua_assert_line_8(((dest != NULL) && (src != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memcpy(dest, src, (size_t)n);
}
void nelua_assert_line_9(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:42:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(dest, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 73, stderr);
    nelua_abort();
  }
}
void nelua_memory_set(void* dest, uint8_t x, uintptr_t n) {
  nelua_assert_line_9((dest != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  memset(dest, (int)x, (size_t)n);
}
void nelua_assert_line_10(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:74:11: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(a and b, 'invalid pointer')\n          \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 1, 79, stderr);
    nelua_abort();
  }
}
bool nelua_memory_equals(void* a, void* b, uintptr_t size) {
  nelua_assert_line_10(((a != NULL) && (b != NULL)), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return (memcmp(a, b, (size_t)size) == 0);
}
void nelua_assert_line_11(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/memory.nelua\033[1m:84:9: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(src, 'invalid pointer')\n        \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 1, 71, stderr);
    nelua_abort();
  }
}
void* nelua_memory_scan(void* src, uint8_t x, uintptr_t size) {
  nelua_assert_line_11((src != NULL), ((nlstring){(uint8_t*)"invalid pointer", 15}));
  return memchr(src, (int)x, (size_t)size);
}
void nelua_memory_spanset_1(nelua_span_usize_ dest, uintptr_t x) {
  for(uintptr_t i = 0U, _end = dest.size; i < _end; i = i + 1) {
    memcpy((void*)(&(*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&dest), i)))), (void*)(&x), 8U);
  }
}
bool nelua_isdigit(uint8_t x) {
  return ((x >= 48U) && (x <= 57U));
}
void nelua_assert_line_12(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:32:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 88, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(p < L_FMTFLAGS.size + 1, \"invalid format (repeated flags)\")\n           \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 129, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_13(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:40:10: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 88, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(not isdigit(strfmt[p]), \"invalid format (width or precision too long)\")\n         \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 140, stderr);
    nelua_abort();
  }
}
uintptr_t nelua_assert_bounds_nlusize(uintptr_t index, uintptr_t len){
  if(nelua_unlikely((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
uintptr_t nelua_scanformat(nluint8_arr0_ptr strfmt, nluint8_arr32_ptr form) {
  uintptr_t p = (uintptr_t)0U;
  while(((strfmt[p] != 0) && (nelua_memory_scan((void*)((nlstring){(uint8_t*)"-+ #0", 5}).data, strfmt[p], 5U) != (void*)NULL))) {
    p = (p + 1);
  }
  nelua_assert_line_12((p < (((nlstring){(uint8_t*)"-+ #0", 5}).size + 1)), ((nlstring){(uint8_t*)"invalid format (repeated flags)", 31}));
  if(nelua_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if(nelua_isdigit(strfmt[p])) {
    p = (p + 1);
  }
  if((strfmt[p] == 46U)) {
    p = (p + 1);
    if(nelua_isdigit(strfmt[p])) {
      p = (p + 1);
    }
    if(nelua_isdigit(strfmt[p])) {
      p = (p + 1);
    }
  }
  nelua_assert_line_13((!nelua_isdigit(strfmt[p])), ((nlstring){(uint8_t*)"invalid format (width or precision too long)", 44}));
  form->v[0] = 37U;
  nelua_memory_copy((void*)(&form->v[1]), (void*)(&strfmt[0]), (p + 1));
  form->v[nelua_assert_bounds_nlusize((p + 2), 32)] = (uint8_t)0U;
  return p;
}
size_t nelua_assert_narrow_nlisize_nlcsize(intptr_t x){
  if(nelua_unlikely(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to csize failed");
  }
  return x;
}
size_t nelua_assert_bounds_nlcsize(size_t index, uintptr_t len){
  if(nelua_unlikely((uintptr_t)index >= len)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
void nelua_addlenmod(nluint8_arr32_ptr form, char* lenmod, size_t lenmodsize) {
  size_t l = nelua_assert_narrow_nlisize_nlcsize(((intptr_t)strlen((char*)(&form->v[0]))));
  uint8_t spec = form->v[nelua_assert_bounds_nlcsize((l - 1), 32)];
  nelua_memory_copy((void*)(&form->v[nelua_assert_bounds_nlcsize((l - 1), 32)]), (void*)lenmod, (uintptr_t)lenmodsize);
  form->v[nelua_assert_bounds_nlcsize(((l + lenmodsize) - 1), 32)] = spec;
  form->v[nelua_assert_bounds_nlcsize((l + lenmodsize), 32)] = (uint8_t)0U;
}
void* nelua_GeneralAllocator_alloc(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return (void*)NULL;
  }
  return malloc((size_t)size);
}
void* nelua_GeneralAllocator_alloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  if(nelua_unlikely((size == 0))) {
    return (void*)NULL;
  }
  return calloc((size_t)size, (size_t)1U);
}
void nelua_GeneralAllocator_dealloc(nelua_GeneralAllocator_ptr self, void* p) {
  if(nelua_unlikely((p == (void*)NULL))) {
    return;
  }
  free(p);
}
void* nelua_GeneralAllocator_realloc(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  if(nelua_unlikely((newsize == 0))) {
    if(nelua_likely((p != (void*)NULL))) {
      free(p);
    }
    return (void*)NULL;
  } else if(nelua_unlikely((newsize == oldsize))) {
    return p;
  }
  return realloc(p, (size_t)newsize);
}
void nelua_assert_line_14(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:72:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 95, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(p ~= nilptr, 'out of memory')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 91, stderr);
    nelua_abort();
  }
}
void* nelua_GeneralAllocator_xalloc0(nelua_GeneralAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GeneralAllocator_alloc0(self, size);
  nelua_assert_line_14((p != (void*)NULL), ((nlstring){(uint8_t*)"out of memory", 13}));
  return p;
}
void* nelua_GeneralAllocator_realloc0(nelua_GeneralAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GeneralAllocator_realloc(self, p, newsize, oldsize);
  if(nelua_likely(((newsize > oldsize) && (p != (void*)NULL)))) {
    memset((void*)(&((nluint8_arr0_ptr)p)[oldsize]), 0, (size_t)(newsize - oldsize));
  }
  return p;
}
nelua_span_pointer_ nelua_GeneralAllocator_spanalloc_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(nelua_likely((size > 0))) {
    nlpointer_arr0_ptr data = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(nelua_likely((data != ((nlpointer_arr0_ptr)NULL)))) {
      return (nelua_span_pointer_){data, size};
    }
  }
  return (nelua_span_pointer_){0};
}
nelua_span_string_ nelua_GeneralAllocator_spanalloc_2(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(nelua_likely((size > 0))) {
    nlstring_arr0_ptr data = ((nlstring_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 16)));
    if(nelua_likely((data != ((nlstring_arr0_ptr)NULL)))) {
      return (nelua_span_string_){data, size};
    }
  }
  return (nelua_span_string_){0};
}
nelua_span_usize_ nelua_GeneralAllocator_spanalloc_3(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(nelua_likely((size > 0))) {
    nlusize_arr0_ptr data = ((nlusize_arr0_ptr)nelua_GeneralAllocator_alloc(self, (size * 8)));
    if(nelua_likely((data != ((nlusize_arr0_ptr)NULL)))) {
      return (nelua_span_usize_){data, size};
    }
  }
  return (nelua_span_usize_){0};
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanalloc0_1(nelua_GeneralAllocator_ptr self, nlniltype T, uintptr_t size) {
  if(nelua_likely((size > 0))) {
    nelua_hashmapnode_pointer__GCItem__arr0_ptr data = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_alloc0(self, (size * 64)));
    if(nelua_likely((data != ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL)))) {
      return (nelua_span_hashmapnode_pointer__GCItem__){data, size};
    }
  }
  return (nelua_span_hashmapnode_pointer__GCItem__){0};
}
void nelua_GeneralAllocator_spandealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
void nelua_GeneralAllocator_spandealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GeneralAllocator_dealloc(self, (void*)s.data);
}
nelua_span_pointer_ nelua_GeneralAllocator_spanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_1(self, NLNIL, size);
    return s;
  }
  nlpointer_arr0_ptr p = ((nlpointer_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((nlpointer_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_usize_ nelua_GeneralAllocator_spanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_3(self, NLNIL, size);
    return s;
  }
  nlusize_arr0_ptr p = ((nlusize_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 8), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((nlusize_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_string_ nelua_GeneralAllocator_spanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc_2(self, NLNIL, size);
    return s;
  }
  nlstring_arr0_ptr p = ((nlstring_arr0_ptr)nelua_GeneralAllocator_realloc(self, (void*)s.data, (size * 16), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((nlstring_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_assert_line_15(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_pointer_ nelua_GeneralAllocator_xspanrealloc_1(nelua_GeneralAllocator_ptr self, nelua_span_pointer_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_1(self, s, size);
  nelua_assert_line_15((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void nelua_assert_line_16(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_usize_ nelua_GeneralAllocator_xspanrealloc_2(nelua_GeneralAllocator_ptr self, nelua_span_usize_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_2(self, s, size);
  nelua_assert_line_16((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void nelua_assert_line_17(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_string_ nelua_GeneralAllocator_xspanrealloc_3(nelua_GeneralAllocator_ptr self, nelua_span_string_ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc_3(self, s, size);
  nelua_assert_line_17((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_spanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GeneralAllocator_spanalloc0_1(self, NLNIL, size);
    return s;
  }
  nelua_hashmapnode_pointer__GCItem__arr0_ptr p = ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)nelua_GeneralAllocator_realloc0(self, (void*)s.data, (size * 64), (s.size * 64)));
  if(nelua_unlikely(((size > 0) && (p == ((nelua_hashmapnode_pointer__GCItem__arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_assert_line_18(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:268:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_hashmapnode_pointer__GCItem__ nelua_GeneralAllocator_xspanrealloc0_1(nelua_GeneralAllocator_ptr self, nelua_span_hashmapnode_pointer__GCItem__ s, uintptr_t size) {
  s = nelua_GeneralAllocator_spanrealloc0_1(self, s, size);
  nelua_assert_line_18((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
nelua_sequenceimpl_string__1_ptr nelua_GeneralAllocator_new_1(nelua_GeneralAllocator_ptr self, nlniltype what, nlniltype size) {
  nelua_sequenceimpl_string__1_ptr ptr = ((nelua_sequenceimpl_string__1_ptr)nelua_GeneralAllocator_xalloc0(self, 24U));
  return ptr;
}
uintptr_t nelua_hash_hash_1(void* v) {
  return ((uintptr_t)v >> 3);
}
uintptr_t nelua_ceilidiv(uintptr_t x, uintptr_t y) {
  return (((x + y) - 1) / y);
}
uintptr_t nelua_hashmod(uintptr_t h, uintptr_t n) {
  return (h % ((n - 1) | 1));
}
uintptr_t nelua_roundpow2(uintptr_t n) {
  if(((n & (n - 1)) == 0)) {
    return n;
  }
  n = (n | (n >> 1));
  n = (n | (n >> 2));
  n = (n | (n >> 4));
  n = (n | (n >> 8));
  n = (n | (n >> 16));
  if(true) {
    n = (n | (n >> 32));
  }
  n = (n + 1);
  return n;
}
void nelua_hashmap_pointer__GCItem__destroy(nelua_hashmap_pointer__GCItem__ptr self) {
  nelua_GeneralAllocator_spandealloc_2((&self->allocator), self->buckets);
  nelua_GeneralAllocator_spandealloc_3((&self->allocator), self->nodes);
  self->buckets = (nelua_span_usize_){0};
  self->nodes = (nelua_span_hashmapnode_pointer__GCItem__){0};
  self->size = (uintptr_t)0U;
  self->free_index = (uintptr_t)0U;
}
nlmulret_nlusize_nlusize_nlusize nelua_hashmap_pointer__GCItem___find(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t hash_index = nelua_hashmod(nelua_hash_hash_1(key), self->buckets.size);
  uintptr_t prev_node_index = UINTPTR_MAX;
  if(nelua_unlikely((self->buckets.size == 0))) {
    return (nlmulret_nlusize_nlusize_nlusize){UINTPTR_MAX, prev_node_index, hash_index};
  }
  uintptr_t node_index = (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index)));
  while((node_index != UINTPTR_MAX)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))));
    if((node->key == key)) {
      return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
    }
    prev_node_index = node_index;
    node_index = node->next;
  }
  return (nlmulret_nlusize_nlusize_nlusize){node_index, prev_node_index, hash_index};
}
void nelua_assert_line_19(bool cond){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:196:15: \033[31m\033[1mruntime error: \033[0m\033[1massertion failed!\033[0m\n      check(j == self.size)\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~\033[0m\n", 1, 182, stderr);
    nelua_abort();
  }
}
void nelua_hashmap_pointer__GCItem__rehash(nelua_hashmap_pointer__GCItem__ptr self, uintptr_t bucket_count) {
  uintptr_t min_buckets_count = nelua_ceilidiv((self->size * 100), 75U);
  if((bucket_count < min_buckets_count)) {
    bucket_count = min_buckets_count;
  }
  bucket_count = nelua_roundpow2(bucket_count);
  uintptr_t node_count = nelua_ceilidiv((bucket_count * 75U), (uintptr_t)100U);
  if(((bucket_count > 0) && (node_count <= self->size))) {
    node_count = (self->size + 1);
  }
  if((((node_count < self->nodes.size) && (self->nodes.size > 0)) && (node_count > 0))) {
    uintptr_t j = (uintptr_t)0U;
    while(((j < self->nodes.size) && (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j))).filled)) {
      j = (j + 1);
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).filled) {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), j))) = (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i)));
        j = (j + 1);
      }
    }
    for(uintptr_t i = j, _end = self->nodes.size; i < _end; i = i + 1) {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))) = (nelua_hashmapnode_pointer__GCItem_){0};
    }
    nelua_assert_line_19((j == self->size));
  }
  self->nodes = nelua_GeneralAllocator_xspanrealloc0_1((&self->allocator), self->nodes, node_count);
  self->buckets = nelua_GeneralAllocator_xspanrealloc_2((&self->allocator), self->buckets, bucket_count);
  nelua_memory_spanset_1(self->buckets, UINTPTR_MAX);
  uintptr_t free_index = UINTPTR_MAX;
  for(intptr_t i = (intptr_t)(self->nodes.size - 1); i >= 0; i = i + -1) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), (uintptr_t)i))));
    if(node->filled) {
      node->next = UINTPTR_MAX;
    } else {
      node->next = free_index;
      free_index = (uintptr_t)i;
    }
  }
  self->free_index = free_index;
  for(uintptr_t i = 0U, _end = self->nodes.size; i < _end; i = i + 1) {
    if((*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).filled) {
      nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).key);
      uintptr_t node_index = _asgnret_1.r1;
      uintptr_t prev_node_index = _asgnret_1.r2;
      uintptr_t hash_index = _asgnret_1.r3;
      if((prev_node_index == UINTPTR_MAX)) {
        (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = i;
      } else {
        (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = i;
      }
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), i))).next = node_index;
    }
  }
}
void nelua_assert_line_20(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/hashmap.nelua\033[1m:252:24: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 83, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(node_index < self.nodes.size, 'not enough space to add a node')\n                       \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 1, 144, stderr);
    nelua_abort();
  }
}
uintptr_t nelua_hashmap_pointer__GCItem___at(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  if(nelua_unlikely((self->buckets.size == 0))) {
    nelua_hashmap_pointer__GCItem__rehash(self, 16U);
  }
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if((node_index != UINTPTR_MAX)) {
    return node_index;
  } else {
    uintptr_t node_index_1 = self->free_index;
    nelua_assert_line_20((node_index_1 < self->nodes.size), ((nlstring){(uint8_t*)"not enough space to add a node", 30}));
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index_1))));
    self->free_index = node->next;
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.key = key, .filled = true, .next = UINTPTR_MAX};
    if((prev_node_index == UINTPTR_MAX)) {
      (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = node_index_1;
    } else {
      (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = node_index_1;
    }
    self->size = (self->size + 1);
    if(nelua_unlikely(((self->size * 100) >= (self->buckets.size * 75U)))) {
      nelua_hashmap_pointer__GCItem__rehash(self, nelua_ceilidiv((self->size * 200U), 75U));
    }
    return node_index_1;
  }
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem____atindex(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), nelua_hashmap_pointer__GCItem___at(self, key)))).value);
}
nelua_GCItem_ptr nelua_hashmap_pointer__GCItem__peek(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  uintptr_t node_index = nelua_hashmap_pointer__GCItem___find(self, key).r1;
  if((node_index != UINTPTR_MAX)) {
    return (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))).value);
  }
  return ((nelua_GCItem_ptr)NULL);
}
nelua_GCItem nelua_hashmap_pointer__GCItem__remove(nelua_hashmap_pointer__GCItem__ptr self, void* key) {
  nlmulret_nlusize_nlusize_nlusize _asgnret_1 = nelua_hashmap_pointer__GCItem___find(self, key);
  uintptr_t node_index = _asgnret_1.r1;
  uintptr_t prev_node_index = _asgnret_1.r2;
  uintptr_t hash_index = _asgnret_1.r3;
  if((node_index == UINTPTR_MAX)) {
    return (nelua_GCItem){0};
  }
  nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), node_index))));
  nelua_GCItem value = node->value;
  if((prev_node_index == UINTPTR_MAX)) {
    (*(uintptr_t*)nelua_assert_deref(nelua_span_usize____atindex((&self->buckets), hash_index))) = node->next;
  } else {
    (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->nodes), prev_node_index))).next = node->next;
  }
  self->size = (self->size - 1);
  (*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(node)) = (nelua_hashmapnode_pointer__GCItem_){.next = self->free_index};
  self->free_index = node_index;
  return value;
}
double nelua_hashmap_pointer__GCItem__loadfactor(nelua_hashmap_pointer__GCItem__ptr self) {
  if(nelua_unlikely((self->buckets.size == 0))) {
    return 0.0;
  } else {
    return (self->size / (double)self->buckets.size);
  }
}
nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr nelua_hashmap_iteratorT_mnext(nelua_hashmap_iteratorT_ptr self, void* key) {
  if(nelua_unlikely((self->index == UINTPTR_MAX))) {
    self->index = (uintptr_t)0U;
  } else {
    self->index = (self->index + 1);
  }
  while((self->index < self->container->nodes.size)) {
    nelua_hashmapnode_pointer__GCItem__ptr node = (&(*(nelua_hashmapnode_pointer__GCItem_*)nelua_assert_deref(nelua_span_hashmapnode_pointer__GCItem_____atindex((&self->container->nodes), self->index))));
    if(node->filled) {
      return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){true, node->key, (&node->value)};
    }
    self->index = (self->index + 1);
  }
  return (nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr){false, NULL, ((nelua_GCItem_ptr)NULL)};
}
nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer nelua_hashmap_pointer__GCItem____mpairs(nelua_hashmap_pointer__GCItem__ptr self) {
  return (nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer){nelua_hashmap_iteratorT_mnext, (nelua_hashmap_iteratorT){.container = self, .index = UINTPTR_MAX}, NULL};
}
void nelua_vector_pointer__clear(nelua_vector_pointer__ptr self) {
  self->size = (uintptr_t)0U;
}
void nelua_vector_pointer__destroy(nelua_vector_pointer__ptr self) {
  nelua_GeneralAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_pointer_){0};
  self->size = (uintptr_t)0U;
}
void nelua_vectorT_grow(nelua_vector_pointer__ptr self) {
  uintptr_t cap = (uintptr_t)1U;
  if(nelua_likely((self->data.size != 0))) {
    cap = (self->data.size * 2);
  }
  self->data = nelua_GeneralAllocator_xspanrealloc_1((&self->allocator), self->data, cap);
}
void nelua_vector_pointer__push(nelua_vector_pointer__ptr self, void* v) {
  uintptr_t newsize = (self->size + 1);
  if(nelua_unlikely((newsize > self->data.size))) {
    nelua_vectorT_grow(self);
  }
  (*(void**)nelua_assert_deref(nelua_span_pointer____atindex((&self->data), self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_21(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/vector.nelua\033[1m:212:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'position out of bounds')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 102, stderr);
    nelua_abort();
  }
}
nlpointer_ptr nelua_vector_pointer____atindex(nelua_vector_pointer__ptr self, uintptr_t i) {
  nelua_assert_line_21((i < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(void**)nelua_assert_deref(nelua_span_pointer____atindex((&self->data), i))));
}
intptr_t nelua_vector_pointer____len(nelua_vector_pointer__ptr self) {
  return (intptr_t)self->size;
}
void nelua_vectorT_grow_1(nelua_vector_pure_line__ptr self) {
  uintptr_t cap = (uintptr_t)1U;
  if(nelua_likely((self->data.size != 0))) {
    cap = (self->data.size * 2);
  }
  self->data = nelua_GCAllocator_xspanrealloc_3((&self->allocator), self->data, cap);
}
void nelua_vector_pure_line__push(nelua_vector_pure_line__ptr self, parser_pure_line v) {
  uintptr_t newsize = (self->size + 1);
  if(nelua_unlikely((newsize > self->data.size))) {
    nelua_vectorT_grow_1(self);
  }
  (*(parser_pure_line*)nelua_assert_deref(nelua_span_pure_line____atindex((&self->data), self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_22(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/vector.nelua\033[1m:212:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'position out of bounds')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 102, stderr);
    nelua_abort();
  }
}
parser_pure_line_ptr nelua_vector_pure_line____atindex(nelua_vector_pure_line__ptr self, uintptr_t i) {
  nelua_assert_line_22((i < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(parser_pure_line*)nelua_assert_deref(nelua_span_pure_line____atindex((&self->data), i))));
}
intptr_t nelua_vector_pure_line____len(nelua_vector_pure_line__ptr self) {
  return (intptr_t)self->size;
}
void nelua_vectorT_grow_2(nelua_vector_line_content__ptr self) {
  uintptr_t cap = (uintptr_t)1U;
  if(nelua_likely((self->data.size != 0))) {
    cap = (self->data.size * 2);
  }
  self->data = nelua_GCAllocator_xspanrealloc_4((&self->allocator), self->data, cap);
}
void nelua_vector_line_content__push(nelua_vector_line_content__ptr self, driver_helper_line_content v) {
  uintptr_t newsize = (self->size + 1);
  if(nelua_unlikely((newsize > self->data.size))) {
    nelua_vectorT_grow_2(self);
  }
  (*(driver_helper_line_content*)nelua_assert_deref(nelua_span_line_content____atindex((&self->data), self->size))) = v;
  self->size = newsize;
}
void nelua_assert_line_23(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/vector.nelua\033[1m:212:13: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(i < self.size, 'position out of bounds')\n            \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 102, stderr);
    nelua_abort();
  }
}
driver_helper_line_content_ptr nelua_vector_line_content____atindex(nelua_vector_line_content__ptr self, uintptr_t i) {
  nelua_assert_line_23((i < self->size), ((nlstring){(uint8_t*)"position out of bounds", 22}));
  return (&(*(driver_helper_line_content*)nelua_assert_deref(nelua_span_line_content____atindex((&self->data), i))));
}
intptr_t nelua_vector_line_content____len(nelua_vector_line_content__ptr self) {
  return (intptr_t)self->size;
}
bool nelua_hasflag(uintptr_t flags, uintptr_t flag) {
  return ((flags & flag) != 0);
}
bool nelua_GCItem_ismarked(nelua_GCItem_ptr self) {
  return nelua_hasflag(self->flags, 3U);
}
bool nelua_GC_unregister_1(nelua_GC_ptr self, void* ptr, bool finalize) {
  if(nelua_unlikely((!(ptr != NULL)))) {
    return false;
  }
  nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
  if(nelua_unlikely((item.ptr != ptr))) {
    return false;
  }
  self->membytes = (self->membytes - item.size);
  for(uintptr_t i = 0U, _end = self->frees.size; i < _end; i = i + 1) {
    if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) == ptr)) {
      (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) = (void*)NULL;
      break;
    }
  }
  if(finalize) {
    if((item.finalizer != NULL)) {
      item.finalizer(ptr, item.userdata);
    }
  }
  return true;
}
void nelua_GC_markptrs(nelua_GC_ptr self, uintptr_t low, uintptr_t high) {
  uintptr_t minaddr = self->minaddr;
  uintptr_t maxaddr = self->maxaddr;
  nelua_hashmap_pointer__GCItem__ptr items = (&self->items);
  for(uintptr_t memaddr = low, _end = high; memaddr < _end; memaddr = memaddr + 8) {
    uintptr_t addr = (*(uintptr_t*)nelua_assert_deref((nlusize_ptr)memaddr));
    if(((addr >= minaddr) && (addr <= maxaddr))) {
      nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek(items, (void*)addr);
      if(((item != NULL) && (!nelua_GCItem_ismarked(item)))) {
        item->flags = (item->flags | 1U);
        if((!nelua_hasflag(item->flags, 4U))) {
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_unmarkall(nelua_GC_ptr self) {
  {
    nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_5CJP53TT7B2LA277q __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      __forit;
      {
        item->flags = (item->flags & 18446744073709551614U);
      }
    }
  }
}
void nelua_GC_markroot(nelua_GC_ptr self) {
  {
    nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_5CJP53TT7B2LA277q __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if(nelua_hasflag(item->flags, 2U)) {
          uintptr_t addr = (uintptr_t)ptr;
          nelua_GC_markptrs(self, addr, (addr + item->size));
        }
      }
    }
  }
}
void nelua_GC_markstackinner(nelua_GC_ptr self) {
  volatile void* stacktop = NULL;
  uintptr_t low = (uintptr_t)self->stackbottom;
  uintptr_t high = (uintptr_t)(&stacktop);
  if((high < low)) {
    uintptr_t _asgntmp_1 = high;
    uintptr_t _asgntmp_2 = low;
    low = _asgntmp_1;
    high = _asgntmp_2;
  }
  nelua_GC_markptrs(self, low, high);
}
void nelua_GC_markstack(nelua_GC_ptr self) {
  jmp_buf regs = {0};
  setjmp(regs);
  volatile function_4gqRYyaV7UKZhzZGK markstackinner = nelua_GC_markstackinner;
  markstackinner(self);
}
void nelua_GC_mark(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_markroot(self);
  nelua_GC_markstack(self);
}
void nelua_assert_line_24(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:222:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n        check(item, 'gc item not found to finalize')\n              \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 99, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_25(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:235:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(item.ptr == ptr, 'gc item not found to deallocate')\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 1, 119, stderr);
    nelua_abort();
  }
}
void nelua_GC_sweep(nelua_GC_ptr self) {
  bool finalize = false;
  {
    nlmulret_function_5CJP53TT7B2LA277q_nelua_hashmap_iteratorT_nlpointer _asgnret_1 = nelua_mpairs_1((&self->items));
    function_5CJP53TT7B2LA277q __fornext = _asgnret_1.r1;
    nelua_hashmap_iteratorT __forstate = _asgnret_1.r2;
    void* __forit = _asgnret_1.r3;
    while(true) {
      bool __forcont;
      nelua_GCItem_ptr item;
      nlmulret_nlboolean_nlpointer_nelua_GCItem_ptr _asgnret_2 = __fornext((&__forstate), __forit);
      __forcont = _asgnret_2.r1;
      __forit = _asgnret_2.r2;
      item = _asgnret_2.r3;
      if((!__forcont)) {
        break;
      }
      void* ptr = __forit;
      {
        if((!nelua_GCItem_ismarked(item))) {
          nelua_vector_pointer__push((&self->frees), ptr);
          if(((!finalize) && (item->finalizer != NULL))) {
            finalize = true;
          }
        }
      }
    }
  }
  if(finalize) {
    {
      nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64 _asgnret_3 = nelua_ipairs_1((&self->frees));
      function_3RiL9KEX25TLkt4er __fornext = _asgnret_3.r1;
      nelua_vector_pointer__ptr __forstate = _asgnret_3.r2;
      int64_t __forit = _asgnret_3.r3;
      while(true) {
        bool __forcont;
        void* ptr;
        nlmulret_nlboolean_nlint64_nlpointer _asgnret_4 = __fornext(__forstate, __forit);
        __forcont = _asgnret_4.r1;
        __forit = _asgnret_4.r2;
        ptr = _asgnret_4.r3;
        if((!__forcont)) {
          break;
        }
        __forit;
        {
          if((ptr != NULL)) {
            nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), ptr);
            nelua_assert_line_24((item != NULL), ((nlstring){(uint8_t*)"gc item not found to finalize", 29}));
            if((item->finalizer != NULL)) {
              nelua_GCFinalizerCallback finalizer = item->finalizer;
              item->finalizer = (nelua_GCFinalizerCallback)NULL;
              finalizer(ptr, item->userdata);
            }
          }
        }
      }
    }
  }
  {
    nlmulret_function_3RiL9KEX25TLkt4er_nelua_vector_pointer__ptr_nlint64 _asgnret_5 = nelua_ipairs_1((&self->frees));
    function_3RiL9KEX25TLkt4er __fornext = _asgnret_5.r1;
    nelua_vector_pointer__ptr __forstate = _asgnret_5.r2;
    int64_t __forit = _asgnret_5.r3;
    while(true) {
      bool __forcont;
      void* ptr;
      nlmulret_nlboolean_nlint64_nlpointer _asgnret_6 = __fornext(__forstate, __forit);
      __forcont = _asgnret_6.r1;
      __forit = _asgnret_6.r2;
      ptr = _asgnret_6.r3;
      if((!__forcont)) {
        break;
      }
      __forit;
      {
        if((ptr != NULL)) {
          nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), ptr);
          nelua_assert_line_25((item.ptr == ptr), ((nlstring){(uint8_t*)"gc item not found to deallocate", 31}));
          self->membytes = (self->membytes - item.size);
          if((!nelua_hasflag(item.flags, 8U))) {
            nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
          }
        }
      }
    }
  }
  nelua_vector_pointer__clear((&self->frees));
}
void nelua_GC_collect(nelua_GC_ptr self) {
  if((self->collecting || (self->membytes == 0))) {
    return;
  }
  self->collecting = true;
  nelua_GC_mark(self);
  nelua_GC_sweep(self);
  self->lastmembytes = self->membytes;
  if((nelua_hashmap_pointer__GCItem__loadfactor((&self->items)) < 0.25)) {
    nelua_hashmap_pointer__GCItem__rehash((&self->items), 0U);
  }
  self->collecting = false;
}
void nelua_GC_registerroots(nelua_GC_ptr self) {
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stderr), 8U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stdout), 8U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_io_stdin), 8U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_arg), 8U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stderrfs), 16U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stdoutfs), 16U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
  nelua_GC_register((&nelua_gc), (void*)(&nelua_stdinfs), 16U, 2U, (function_2wTCtLbGnp96MYzKT)NULL, (void*)NULL);
}
void nelua_GC_maybecollect(nelua_GC_ptr self) {
  if(((self->running && (!self->collecting)) && (self->membytes >= ((self->lastmembytes * self->pause) / 100)))) {
    nelua_GC_collect(self);
  }
}
void nelua_assert_line_26(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:328:18: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(item.ptr == nilptr, 'cannot register pointer twice')\n                 \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 115, stderr);
    nelua_abort();
  }
}
void nelua_GC_register(nelua_GC_ptr self, void* ptr, uintptr_t size, uintptr_t flags, function_2wTCtLbGnp96MYzKT finalizer, void* userdata) {
  if(nelua_unlikely((!(ptr != NULL)))) {
    return;
  }
  if((size < 8)) {
    flags = (flags | 4U);
  }
  nelua_GCItem_ptr item = (&(*(nelua_GCItem*)nelua_assert_deref(nelua_hashmap_pointer__GCItem____atindex((&self->items), ptr))));
  nelua_assert_line_26((item->ptr == (void*)NULL), ((nlstring){(uint8_t*)"cannot register pointer twice", 29}));
  (*(nelua_GCItem*)nelua_assert_deref(item)) = (nelua_GCItem){.flags = flags, .size = size, .ptr = ptr, .finalizer = finalizer, .userdata = userdata};
  if((!nelua_hasflag(item->flags, 2U))) {
    uintptr_t addr = (uintptr_t)ptr;
    uintptr_t addrhigh = (addr + size);
    if((addrhigh > self->maxaddr)) {
      self->maxaddr = addrhigh;
    }
    if((addr < self->minaddr)) {
      self->minaddr = addr;
    }
  }
  self->membytes = (self->membytes + size);
  nelua_GC_maybecollect(self);
}
void nelua_assert_line_27(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:353:27: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(oldptr and newptr and newsize > 0, 'invalid pointer reregister arguments')\n                          \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 1, 152, stderr);
    nelua_abort();
  }
}
bool nelua_GC_reregister(nelua_GC_ptr self, void* oldptr, void* newptr, uintptr_t newsize) {
  nelua_assert_line_27((((oldptr != NULL) && (newptr != NULL)) && (newsize > 0)), ((nlstring){(uint8_t*)"invalid pointer reregister arguments", 36}));
  uintptr_t oldsize = 0U;
  if((newptr == oldptr)) {
    nelua_GCItem_ptr item = nelua_hashmap_pointer__GCItem__peek((&self->items), oldptr);
    if(nelua_unlikely((!(item != NULL)))) {
      return false;
    }
    oldsize = item->size;
    item->size = newsize;
    if((newsize > oldsize)) {
      self->membytes = (self->membytes + (newsize - oldsize));
    } else if((newsize < oldsize)) {
      self->membytes = (self->membytes - (oldsize - newsize));
    }
  } else {
    nelua_GCItem item = nelua_hashmap_pointer__GCItem__remove((&self->items), oldptr);
    if(nelua_unlikely((item.ptr != oldptr))) {
      return false;
    }
    oldsize = item.size;
    self->membytes = (self->membytes - oldsize);
    for(uintptr_t i = 0U, _end = self->frees.size; i < _end; i = i + 1) {
      if(((*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) == oldptr)) {
        (*(void**)nelua_assert_deref(nelua_vector_pointer____atindex((&self->frees), i))) = newptr;
        break;
      }
    }
    nelua_GC_register(self, newptr, newsize, item.flags, item.finalizer, item.userdata);
  }
  if((newsize > oldsize)) {
    nelua_GC_maybecollect(self);
  }
  return true;
}
void nelua_GC_restart(nelua_GC_ptr self) {
  self->running = true;
}
void nelua_GC_init(nelua_GC_ptr self, void* stack) {
  self->stackbottom = stack;
  self->minaddr = UINTPTR_MAX;
  self->pause = (uintptr_t)200U;
  nelua_GC_registerroots(self);
  nelua_GC_restart(self);
}
void nelua_GC_destroy(nelua_GC_ptr self) {
  nelua_GC_unmarkall(self);
  nelua_GC_sweep(self);
  nelua_hashmap_pointer__GCItem__destroy((&self->items));
  nelua_vector_pointer__destroy((&self->frees));
  (*(nelua_GC*)nelua_assert_deref(self)) = (nelua_GC){0};
}
int main(int argc, nlcstring_ptr argv) {
  nelua_GC_init((&nelua_gc), (void*)(&argc));
  volatile function_3a75JJwhuWwoVVKzM inner_main = nelua_main;
  int ret = inner_main(argc, argv);
  nelua_GC_destroy((&nelua_gc));
  return ret;
}
void* nelua_GCAllocator_alloc_1(nelua_GCAllocator_ptr self, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_1 = (uintptr_t)0U;
  nelua_GCFinalizerCallback finalizer_1 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_1 = (void*)NULL;
  void* ptr = nelua_GeneralAllocator_alloc((&nelua_general_allocator), size);
  nelua_GC_register((&nelua_gc), ptr, size, flags_1, finalizer_1, userdata_1);
  return ptr;
}
void* nelua_GCAllocator_alloc_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  void* ptr = nelua_GeneralAllocator_alloc((&nelua_general_allocator), size);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void* nelua_GCAllocator_alloc0_2(nelua_GCAllocator_ptr self, uintptr_t size, uintptr_t flags, nelua_GCFinalizerCallback finalizer, void* userdata) {
  void* ptr = nelua_GeneralAllocator_alloc0((&nelua_general_allocator), size);
  nelua_GC_register((&nelua_gc), ptr, size, flags, finalizer, userdata);
  return ptr;
}
void nelua_GCAllocator_dealloc(nelua_GCAllocator_ptr self, void* ptr) {
  nelua_GC_unregister_1((&nelua_gc), ptr, true);
  nelua_GeneralAllocator_dealloc((&nelua_general_allocator), ptr);
}
void* nelua_GCAllocator_realloc(nelua_GCAllocator_ptr self, void* ptr, uintptr_t newsize, uintptr_t oldsize) {
  if(nelua_unlikely((ptr == (void*)NULL))) {
    return nelua_GCAllocator_alloc_1(self, newsize, NLNIL, NLNIL, NLNIL);
  } else if(nelua_unlikely((newsize == 0))) {
    nelua_GCAllocator_dealloc(self, ptr);
    return (void*)NULL;
  } else if(nelua_unlikely((newsize == oldsize))) {
    return ptr;
  } else {
    void* newptr = nelua_GeneralAllocator_realloc((&nelua_general_allocator), ptr, newsize, oldsize);
    if((newptr != NULL)) {
      nelua_GC_reregister((&nelua_gc), ptr, newptr, newsize);
    }
    return newptr;
  }
}
nelua_span_pure_line_ nelua_GCAllocator_spanalloc_2(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_2 = (uintptr_t)0U;
  nelua_GCFinalizerCallback finalizer_2 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_2 = (void*)NULL;
  if(nelua_likely((size > 0))) {
    parser_pure_line_arr0_ptr data = ((parser_pure_line_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 808), flags_2, finalizer_2, userdata_2));
    if(nelua_likely((data != ((parser_pure_line_arr0_ptr)NULL)))) {
      return (nelua_span_pure_line_){data, size};
    }
  }
  return (nelua_span_pure_line_){0};
}
nelua_span_line_content_ nelua_GCAllocator_spanalloc_3(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_3 = (uintptr_t)0U;
  nelua_GCFinalizerCallback finalizer_3 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_3 = (void*)NULL;
  if(nelua_likely((size > 0))) {
    driver_helper_line_content_arr0_ptr data = ((driver_helper_line_content_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 40), flags_3, finalizer_3, userdata_3));
    if(nelua_likely((data != ((driver_helper_line_content_arr0_ptr)NULL)))) {
      return (nelua_span_line_content_){data, size};
    }
  }
  return (nelua_span_line_content_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc_4(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_4 = (uintptr_t)0U;
  flags_4 = 4U;
  nelua_GCFinalizerCallback finalizer_4 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_4 = (void*)NULL;
  if(nelua_likely((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc_2(self, (size * 1), flags_4, finalizer_4, userdata_4));
    if(nelua_likely((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){data, size};
    }
  }
  return (nelua_span_uint8_){0};
}
nelua_span_uint8_ nelua_GCAllocator_spanalloc0_1(nelua_GCAllocator_ptr self, nlniltype T, uintptr_t size, nlniltype flags, nlniltype finalizer, nlniltype userdata) {
  uintptr_t flags_5 = (uintptr_t)0U;
  flags_5 = 4U;
  nelua_GCFinalizerCallback finalizer_5 = (nelua_GCFinalizerCallback)NULL;
  void* userdata_5 = (void*)NULL;
  if(nelua_likely((size > 0))) {
    nluint8_arr0_ptr data = ((nluint8_arr0_ptr)nelua_GCAllocator_alloc0_2(self, (size * 1), flags_5, finalizer_5, userdata_5));
    if(nelua_likely((data != ((nluint8_arr0_ptr)NULL)))) {
      return (nelua_span_uint8_){data, size};
    }
  }
  return (nelua_span_uint8_){0};
}
void nelua_assert_line_28(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/gc.nelua\033[1m:676:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(ptr ~= nilptr, 'out of memory')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 95, stderr);
    nelua_abort();
  }
}
nelua_FStream_ptr nelua_GCAllocator_new_2(nelua_GCAllocator_ptr self, nelua_FStream what, nlniltype size) {
  nelua_GCFinalizerCallback finalizer = (nelua_GCFinalizerCallback)NULL;
  uintptr_t flags = (uintptr_t)0U;
  nelua_FStream_ptr ptr;
  ptr = ((nelua_FStream_ptr)nelua_GCAllocator_alloc_2((&nelua_gc_allocator), 16U, flags, finalizer, (void*)NULL));
  nelua_assert_line_28((ptr != ((nelua_FStream_ptr)NULL)), ((nlstring){(uint8_t*)"out of memory", 13}));
  nelua_memory_copy((void*)ptr, (void*)(&what), 16U);
  return ptr;
}
void nelua_assert_line_29(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:54:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 95, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(p ~= nilptr, 'out of memory')\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 91, stderr);
    nelua_abort();
  }
}
void* nelua_GCAllocator_xalloc(nelua_GCAllocator_ptr self, uintptr_t size) {
  void* p = nelua_GCAllocator_alloc_1(self, size, NLNIL, NLNIL, NLNIL);
  nelua_assert_line_29((p != (void*)NULL), ((nlstring){(uint8_t*)"out of memory", 13}));
  return p;
}
void* nelua_GCAllocator_realloc0(nelua_GCAllocator_ptr self, void* p, uintptr_t newsize, uintptr_t oldsize) {
  p = nelua_GCAllocator_realloc(self, p, newsize, oldsize);
  if(nelua_likely(((newsize > oldsize) && (p != (void*)NULL)))) {
    memset((void*)(&((nluint8_arr0_ptr)p)[oldsize]), 0, (size_t)(newsize - oldsize));
  }
  return p;
}
void nelua_GCAllocator_spandealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s) {
  if(nelua_unlikely((s.size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc(self, (void*)s.data);
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_4(self, NLNIL, size, NLNIL, NLNIL, NLNIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 1), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_pure_line_ nelua_GCAllocator_spanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_2(self, NLNIL, size, NLNIL, NLNIL, NLNIL);
    return s;
  }
  parser_pure_line_arr0_ptr p = ((parser_pure_line_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 808), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((parser_pure_line_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
nelua_span_line_content_ nelua_GCAllocator_spanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_line_content_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc_3(self, NLNIL, size, NLNIL, NLNIL, NLNIL);
    return s;
  }
  driver_helper_line_content_arr0_ptr p = ((driver_helper_line_content_arr0_ptr)nelua_GCAllocator_realloc(self, (void*)s.data, (size * 40), s.size));
  if(nelua_unlikely(((size > 0) && (p == ((driver_helper_line_content_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_assert_line_30(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_uint8_ nelua_GCAllocator_xspanrealloc_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_1(self, s, size);
  nelua_assert_line_30((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void nelua_assert_line_31(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_pure_line_ nelua_GCAllocator_xspanrealloc_3(nelua_GCAllocator_ptr self, nelua_span_pure_line_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_3(self, s, size);
  nelua_assert_line_31((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
void nelua_assert_line_32(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/allocators/allocator.nelua\033[1m:242:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 96, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(s.size == size, 'out of memory')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
nelua_span_line_content_ nelua_GCAllocator_xspanrealloc_4(nelua_GCAllocator_ptr self, nelua_span_line_content_ s, uintptr_t size) {
  s = nelua_GCAllocator_spanrealloc_4(self, s, size);
  nelua_assert_line_32((s.size == size), ((nlstring){(uint8_t*)"out of memory", 13}));
  return s;
}
nelua_span_uint8_ nelua_GCAllocator_spanrealloc0_1(nelua_GCAllocator_ptr self, nelua_span_uint8_ s, uintptr_t size) {
  if(nelua_unlikely(((s.size == 0) && (size > 0)))) {
    s = nelua_GCAllocator_spanalloc0_1(self, NLNIL, size, NLNIL, NLNIL, NLNIL);
    return s;
  }
  nluint8_arr0_ptr p = ((nluint8_arr0_ptr)nelua_GCAllocator_realloc0(self, (void*)s.data, (size * 1), (s.size * 1)));
  if(nelua_unlikely(((size > 0) && (p == ((nluint8_arr0_ptr)NULL))))) {
    return s;
  }
  s.data = p;
  s.size = size;
  return s;
}
void nelua_stringbuilderT_destroy(nelua_stringbuilderT_ptr self) {
  nelua_GCAllocator_spandealloc_1((&self->allocator), self->data);
  self->data = (nelua_span_uint8_){0};
  self->size = (uintptr_t)0U;
}
bool nelua_stringbuilderT_grow(nelua_stringbuilderT_ptr self, uintptr_t newsize) {
  uintptr_t needed = (newsize + 1);
  uintptr_t cap = self->data.size;
  if((needed <= cap)) {
    return true;
  }
  if((cap == 0)) {
    cap = 128U;
  }
  while(1) {
    cap = (cap * 2);
    if((cap >= needed)) {
      break;
    }
  }
  self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, cap);
  if((self->data.size != cap)) {
    self->data = nelua_GCAllocator_spanrealloc0_1((&self->allocator), self->data, needed);
  }
  return (needed <= self->data.size);
}
nelua_span_uint8_ nelua_stringbuilderT_prepare(nelua_stringbuilderT_ptr self, uintptr_t n) {
  if((!nelua_stringbuilderT_grow(self, (self->size + n)))) {
    return (nelua_span_uint8_){0};
  }
  return (nelua_span_uint8_){.data = ((nluint8_arr0_ptr)(&(*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex((&self->data), self->size))))), .size = ((self->data.size - self->size) - 1)};
}
void nelua_assert_line_33(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:145:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(newsize <= self.data.size, 'not enough space in string buffer')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~\033[0m\n", 1, 137, stderr);
    nelua_abort();
  }
}
void nelua_stringbuilderT_commit(nelua_stringbuilderT_ptr self, uintptr_t n) {
  uintptr_t newsize = (self->size + n);
  nelua_assert_line_33((newsize <= self->data.size), ((nlstring){(uint8_t*)"not enough space in string buffer", 33}));
  self->size = newsize;
}
bool nelua_stringbuilderT_writebyte_1(nelua_stringbuilderT_ptr self, uint8_t c, nlniltype n) {
  uintptr_t n_1 = (uintptr_t)1U;
  nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, n_1);
  if(nelua_unlikely(nelua_span_uint8__empty((&p)))) {
    return false;
  }
  nelua_memory_set((void*)p.data, c, n_1);
  self->size = (self->size + n_1);
  return true;
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_write_1(nelua_stringbuilderT_ptr self, nlstring __arg1) {
  uintptr_t written = (uintptr_t)0U;
  nlstring s = __arg1;
  if((s.size > 0)) {
    nelua_span_uint8_ p = nelua_stringbuilderT_prepare(self, s.size);
    if(nelua_unlikely(nelua_span_uint8__empty((&p)))) {
      return (nlmulret_nlboolean_nlusize){false, written};
    }
    nelua_memory_copy((void*)p.data, (void*)s.data, s.size);
    written = (written + s.size);
    self->size = (self->size + s.size);
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
int nelua_assert_narrow_nlusize_nlcint(uintptr_t x){
  if(nelua_unlikely(x > 0x7fffffffU)) {
    nelua_panic_cstring("narrow casting from usize to cint failed");
  }
  return x;
}
void nelua_assert_line_34(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:291:12: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(false, 'invalid format for argument')\n           \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 1, 93, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_35(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:293:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(nb >= 0 and nb < (@isize)(maxitem), 'unexpected number of bytes written in sprintf')\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 169, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlcint nelua_formatarg_2(nelua_stringbuilderT_ptr self, uint8_t c, char* buff, uintptr_t maxitem, nluint8_arr32_ptr form, int64_t arg1) {
  int nb = -1;
  if((c == 99U)) {
    int n = (int)arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if(((((((c == 100U) || (c == 105U)) || (c == 111U)) || (c == 117U)) || (c == 120U)) || (c == 88U))) {
    nelua_addlenmod(form, PRIi64, nelua_assert_narrow_nlisize_nlcsize((((intptr_t)strlen(PRIi64)) - 1)));
    int64_t n = arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if((((((((c == 97U) || (c == 65U)) || (c == 102U)) || (c == 101U)) || (c == 69U)) || (c == 103U)) || (c == 71U))) {
    double n = (double)arg1;
    nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), n);
    goto nelua_next_4;
  }
  if((c == 115U)) {
    nlstring s = nelua_tostring_2(arg1);
    maxitem = (s.size + 1);
    buff = (char*)nelua_stringbuilderT_prepare(self, maxitem).data;
    if((buff != NULL)) {
      if(((form->v[1] == c) && (form->v[2] == 0))) {
        nelua_memory_copy((void*)buff, (void*)s.data, s.size);
        nb = nelua_assert_narrow_nlusize_nlcint(s.size);
      } else {
        nb = snprintf(buff, (size_t)maxitem, (char*)(&form->v[0]), s.data);
      }
    }
    nelua_nlstring_destroy((&s));
    if((!(buff != NULL))) {
      return (nlmulret_nlboolean_nlcint){false, 0};
    }
    goto nelua_next_4;
  }
  nelua_assert_line_34(false, ((nlstring){(uint8_t*)"invalid format for argument", 27}));
nelua_next_4:;
  nelua_assert_line_35(((nb >= 0) && (nb < (intptr_t)maxitem)), ((nlstring){(uint8_t*)"unexpected number of bytes written in sprintf", 45}));
  return (nlmulret_nlboolean_nlcint){true, nb};
}
void nelua_assert_line_36(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/stringbuilder.nelua\033[1m:341:21: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 89, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n          assert(nb >= 0, 'missing argument in format')\n                    \033[1m\033[32m^\033[0m\033[35m~~~\033[0m\n", 1, 108, stderr);
    nelua_abort();
  }
}
nlmulret_nlboolean_nlusize nelua_stringbuilderT_writef_2(nelua_stringbuilderT_ptr self, nlstring fmt, int64_t __arg1) {
  uintptr_t pos = (uintptr_t)0U;
  uintptr_t written = (uintptr_t)0U;
  int32_t argi = 0;
  while((pos < fmt.size)) {
    uint8_t c = fmt.data[pos];
    pos = (pos + 1);
    if((c != 37U)) {
      if((!nelua_stringbuilderT_writebyte_1(self, c, NLNIL))) {
        return (nlmulret_nlboolean_nlusize){false, written};
      }
      written = (written + 1);
    } else {
      c = fmt.data[pos];
      if((c == 37U)) {
        if((!nelua_stringbuilderT_writebyte_1(self, 37U, NLNIL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        written = (written + 1);
        pos = (pos + 1);
      } else {
        nluint8_arr32 form = {0};
        uintptr_t maxitem = 120U;
        char* buff = (char*)nelua_stringbuilderT_prepare(self, 120U).data;
        if((!(buff != NULL))) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        pos = (pos + nelua_scanformat(((nluint8_arr0_ptr)(&fmt.data[pos])), (&form)));
        c = fmt.data[pos];
        pos = (pos + 1);
        argi = (argi + 1);
        bool ok = false;
        int nb = -1;
        if((1 == argi)) {
          nlmulret_nlboolean_nlcint _asgnret_1 = nelua_formatarg_2(self, c, buff, maxitem, (&form), __arg1);
          ok = _asgnret_1.r1;
          nb = _asgnret_1.r2;
          goto nelua_next_2;
        }
nelua_next_2:;
        if((!ok)) {
          return (nlmulret_nlboolean_nlusize){false, written};
        }
        nelua_assert_line_36((nb >= 0), ((nlstring){(uint8_t*)"missing argument in format", 26}));
        nelua_stringbuilderT_commit(self, (uintptr_t)nb);
        written = (written + (uintptr_t)nb);
      }
    }
  }
  return (nlmulret_nlboolean_nlusize){true, written};
}
nlstring nelua_stringbuilderT_promote(nelua_stringbuilderT_ptr self) {
  if(nelua_unlikely((self->size == 0))) {
    return (nlstring){0};
  }
  uintptr_t size = self->size;
  nelua_span_uint8_ data = nelua_GCAllocator_xspanrealloc_1((&self->allocator), self->data, (size + 1));
  (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex((&data), size))) = (uint8_t)0U;
  self->data = (nelua_span_uint8_){0};
  self->size = (uintptr_t)0U;
  return (nlstring){.data = data.data, .size = size};
}
void nelua_sequence_string__1__init(nelua_sequence_string__1_ptr self) {
  if(nelua_likely((self->impl != NULL))) {
    return;
  }
  self->impl = nelua_GeneralAllocator_new_1((&self->allocator), NLNIL, NLNIL);
}
void nelua_sequence_string__1_reserve(nelua_sequence_string__1_ptr self, uintptr_t n) {
  nelua_sequence_string__1__init(self);
  uintptr_t cap = (n + 1);
  uintptr_t curcap = self->impl->data.size;
  if((curcap >= cap)) {
    return;
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->impl->data, cap);
  if(nelua_unlikely((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex((&self->impl->data), 0U))) = (nlstring){0};
  }
}
void nelua_sequenceT_grow_1(nelua_sequence_string__1_ptr self) {
  uintptr_t cap = (uintptr_t)2U;
  uintptr_t curcap = self->impl->data.size;
  if(nelua_likely((curcap != 0))) {
    cap = (curcap * 2);
  }
  self->impl->data = nelua_GeneralAllocator_xspanrealloc_3((&self->allocator), self->impl->data, cap);
  if(nelua_unlikely((curcap == 0))) {
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex((&self->impl->data), 0U))) = (nlstring){0};
  }
}
void nelua_assert_line_37(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/sequence.nelua\033[1m:248:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 84, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n      check(i == self.impl.size + 1, 'position out of bounds')\n              \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 126, stderr);
    nelua_abort();
  }
}
nlstring_ptr nelua_sequence_string__1___atindex(nelua_sequence_string__1_ptr self, uintptr_t i) {
  nelua_sequence_string__1__init(self);
  if(nelua_unlikely((i > self->impl->size))) {
    nelua_assert_line_37((i == (self->impl->size + 1)), ((nlstring){(uint8_t*)"position out of bounds", 22}));
    self->impl->size = (self->impl->size + 1);
    if(nelua_unlikely(((self->impl->size + 1) > self->impl->data.size))) {
      nelua_sequenceT_grow_1(self);
    }
    (*(nlstring*)nelua_assert_deref(nelua_span_string____atindex((&self->impl->data), i))) = (nlstring){0};
  } else if(nelua_unlikely(((self->impl->data.size == 0) && (i == 0)))) {
    nelua_sequenceT_grow_1(self);
  }
  return (&(*(nlstring*)nelua_assert_deref(nelua_span_string____atindex((&self->impl->data), i))));
}
intptr_t nelua_sequence_string__1___len(nelua_sequence_string__1_ptr self) {
  if(nelua_unlikely((!(self->impl != NULL)))) {
    return 0;
  }
  return (intptr_t)self->impl->size;
}
void nelua_assert_line_38(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:44:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(size > 0, 'attempt to create an empty string')\n             \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 1, 99, stderr);
    nelua_abort();
  }
}
nlstring nelua_nlstring_create(uintptr_t size) {
  nelua_assert_line_38((size > 0), ((nlstring){(uint8_t*)"attempt to create an empty string", 33}));
  nlstring s = (nlstring){.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc((&nelua_gc_allocator), (size + 1))), .size = size};
  s.data[size] = (uint8_t)0U;
  return s;
}
void nelua_nlstring_destroy(nlstring_ptr self) {
  if(nelua_unlikely((self->size == 0))) {
    return;
  }
  nelua_GCAllocator_dealloc((&nelua_gc_allocator), (void*)self->data);
  self->data = ((nluint8_arr0_ptr)NULL);
  self->size = (uintptr_t)0U;
}
nlstring nelua_nlstring_copy(nlstring s) {
  nlstring clone = {0};
  if(nelua_unlikely((s.size == 0))) {
    return clone;
  }
  clone.data = ((nluint8_arr0_ptr)nelua_GCAllocator_xalloc((&nelua_gc_allocator), (s.size + 1)));
  nelua_memory_copy((void*)clone.data, (void*)s.data, s.size);
  clone.data[s.size] = (uint8_t)0U;
  clone.size = s.size;
  return clone;
}
void nelua_assert_line_39(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:96:16: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 81, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  check(i >= 1 and (@usize)(i) <= s.size, 'index out of range')\n               \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 132, stderr);
    nelua_abort();
  }
}
uint8_t nelua_nlstring_byte_1(nlstring s, nlniltype i) {
  intptr_t i_1 = 1;
  if(nelua_unlikely((s.size == 0))) {
    return (uint8_t)0U;
  }
  if(nelua_unlikely((i_1 < 0))) {
    i_1 = (intptr_t)((int64_t)(s.size + i_1) + 1);
  }
  nelua_assert_line_39(((i_1 >= 1) && ((uintptr_t)i_1 <= s.size)), ((nlstring){(uint8_t*)"index out of range", 18}));
  return s.data[(i_1 - 1)];
}
nlstring nelua_nlstring_sub_1(nlstring s, intptr_t i, intptr_t j) {
  intptr_t size = (intptr_t)s.size;
  if(nelua_unlikely((size == 0))) {
    return (nlstring){0};
  }
  if(nelua_unlikely((i < 0))) {
    i = ((size + i) + 1);
  }
  if(nelua_unlikely((i <= 0))) {
    i = 1;
  }
  if(nelua_unlikely((j < 0))) {
    j = ((size + j) + 1);
  }
  if(nelua_unlikely((j > size))) {
    j = size;
  }
  if(nelua_unlikely(((i == 1) && (j == size)))) {
    return nelua_nlstring_copy(s);
  }
  if(nelua_unlikely((i > j))) {
    return (nlstring){0};
  }
  uintptr_t subsize = (uintptr_t)((j - i) + 1);
  if(nelua_unlikely((subsize == 0))) {
    return (nlstring){0};
  }
  nlstring ret = nelua_nlstring_create(subsize);
  nelua_memory_copy((void*)(&ret.data[0]), (void*)(&s.data[(i - 1)]), subsize);
  return ret;
}
nlstring nelua_nlstring_lower(nlstring s) {
  if(nelua_unlikely((s.size == 0))) {
    return s;
  }
  nlstring ret = nelua_nlstring_create(s.size);
  for(uintptr_t i = 0U, _end = s.size; i < _end; i = i + 1) {
    ret.data[i] = (uint8_t)tolower((int)s.data[i]);
  }
  return ret;
}
nlstring nelua_nlstring_format_2(nlstring fmt, int64_t __arg1) {
  nelua_stringbuilderT sb = {0};
  nelua_stringbuilderT_writef_2((&sb), fmt, __arg1);
  return nelua_stringbuilderT_promote((&sb));
}
intptr_t nelua_nlstring___len(nlstring a) {
  return (intptr_t)a.size;
}
bool nelua_nlstring___eq(nlstring a, nlstring b) {
  return ((a.size == b.size) && (((a.data == b.data) || (a.size == 0)) || nelua_memory_equals((void*)a.data, (void*)b.data, a.size)));
}
void nelua_assert_line_40(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:639:17: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(s.size > 0, \"invalid number format\")\n                \033[1m\033[32m^\033[0m\033[35m~~\033[0m\n", 1, 93, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_41(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:643:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(base >= 2 and base <= 36, \"base out of range\")\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~\033[0m\n", 1, 117, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_42(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:647:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(pos < s.size, \"invalid number format\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~\033[0m\n", 1, 97, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_43(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:666:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(x < (@cint)(base), \"invalid number format\")\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~\033[0m\n", 1, 111, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_44(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:671:14: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(pos == s.size, \"invalid number format\") -- fully parsed?\n             \033[1m\033[32m^\033[0m\033[35m~~~~~~~~\033[0m\n", 1, 116, stderr);
    nelua_abort();
  }
}
int64_t nelua_str2intbase(nlstring s, uint64_t base) {
  nelua_assert_line_40((s.size > 0), ((nlstring){(uint8_t*)"invalid number format", 21}));
  nelua_assert_line_41(((base >= 2) && (base <= 36)), ((nlstring){(uint8_t*)"base out of range", 17}));
  uintptr_t pos = (uintptr_t)0U;
  while(((pos < s.size) && (isspace((int)s.data[pos]) != 0))) {
    pos = (pos + 1);
  }
  nelua_assert_line_42((pos < s.size), ((nlstring){(uint8_t*)"invalid number format", 21}));
  bool neg = false;
  if((s.data[pos] == 45U)) {
    pos = (pos + 1);
    neg = true;
  } else if((s.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  uint64_t n = (uint64_t)0U;
  while((pos < s.size)) {
    uint8_t digit = s.data[pos];
    int x = 0;
    if(((digit >= 48U) && (digit <= 57U))) {
      x = (int)(digit - 48U);
    } else if((isalnum((int)digit) != 0)) {
      x = (int)((toupper((int)digit) - 65U) + 10);
    } else {
      break;
    }
    nelua_assert_line_43((x < (int)base), ((nlstring){(uint8_t*)"invalid number format", 21}));
    n = ((n * base) + (uint64_t)x);
    pos = (pos + 1);
  }
  while(((pos < s.size) && (isspace((int)s.data[pos]) != 0))) {
    pos = (pos + 1);
  }
  nelua_assert_line_44((pos == s.size), ((nlstring){(uint8_t*)"invalid number format", 21}));
  if(neg) {
    n = (-n);
  }
  return (int64_t)n;
}
void nelua_assert_line_45(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:735:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(size >= 0 and size < #tmpbuf-1, \"tostring format failed or truncated\")\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 151, stderr);
    nelua_abort();
  }
}
uintptr_t nelua_assert_narrow_nlcint_nlusize(int x){
  if(nelua_unlikely(x < 0)) {
    nelua_panic_cstring("narrow casting from cint to usize failed");
  }
  return x;
}
nlstring nelua_tostring_1(intptr_t x) {
  nluint8_arr48 tmpbuf;
  tmpbuf.v[47] = (uint8_t)0U;
  int size = snprintf((char*)(&tmpbuf), 47U, "%" PRIiPTR, x);
  nelua_assert_line_45(((size >= 0) && (size < 47)), ((nlstring){(uint8_t*)"tostring format failed or truncated", 35}));
  return nelua_nlstring_copy((nlstring){((nluint8_arr0_ptr)(&tmpbuf.v[0])), nelua_assert_narrow_nlcint_nlusize(size)});
}
void nelua_assert_line_46(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/string.nelua\033[1m:735:22: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 82, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    assert(size >= 0 and size < #tmpbuf-1, \"tostring format failed or truncated\")\n                     \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 151, stderr);
    nelua_abort();
  }
}
nlstring nelua_tostring_2(int64_t x) {
  nluint8_arr48 tmpbuf;
  tmpbuf.v[47] = (uint8_t)0U;
  int size = snprintf((char*)(&tmpbuf), 47U, "%" PRIi64, x);
  nelua_assert_line_46(((size >= 0) && (size < 47)), ((nlstring){(uint8_t*)"tostring format failed or truncated", 35}));
  return nelua_nlstring_copy((nlstring){((nluint8_arr0_ptr)(&tmpbuf.v[0])), nelua_assert_narrow_nlcint_nlusize(size)});
}
uint64_t nelua_assert_narrow_nlint64_nluint64(int64_t x){
  if(nelua_unlikely(x < 0)) {
    nelua_panic_cstring("narrow casting from int64 to uint64 failed");
  }
  return x;
}
int64_t nelua_tointeger_1(nlstring x, int64_t base) {
  return nelua_str2intbase(x, nelua_assert_narrow_nlint64_nluint64(base));
}
nlstring nelua_cstring2string(const char* s){
  if(s == NULL) return (nlstring){0};
  uintptr_t size = strlen(s);
  if(size == 0) return (nlstring){0};
  return (nlstring){(uint8_t*)s, size};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_fileresult(bool success) {
  if((!success)) {
    nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = false;
    _mulret_1.r2 = nelua_cstring2string(strerror(errno));
    _mulret_1.r3 = (int64_t)errno;
    return _mulret_1;
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nelua_filestream nelua_filestream__fromfp(FILE_ptr fp, function_5Ch8aJn9o3Dod1HWE closef) {
  return (nelua_filestream){.fs = nelua_GCAllocator_new_2((&nelua_gc_allocator), (nelua_FStream){.fp = fp, .closef = closef}, NLNIL)};
}
FILE_ptr nelua_filestream__getfp(nelua_filestream_ptr self) {
  if((!(self->fs != NULL))) {
    return ((FILE_ptr)NULL);
  }
  return self->fs->fp;
}
bool nelua_checkmode(nlstring mode) {
  if((nelua_nlstring___len(mode) == 0)) {
    return false;
  }
  if((nelua_memory_scan((void*)"rwa", mode.data[0], (uintptr_t)3U) == (void*)NULL)) {
    return false;
  }
  uintptr_t pos = (uintptr_t)1U;
  if((mode.data[pos] == 43U)) {
    pos = (pos + 1);
  }
  if((mode.data[pos] == 98U)) {
    pos = (pos + 1);
  }
  return (mode.data[pos] == 0);
}
void nelua_assert_line_47(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/filestream.nelua\033[1m:110:19: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 86, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n  assert(checkmode(mode), 'invalid mode')\n                  \033[1m\033[32m^\033[0m\033[35m~~~~~\033[0m\n", 1, 94, stderr);
    nelua_abort();
  }
}
char* nelua_assert_string2cstring(nlstring s){
    if(s.size == 0) {
      return (char*)"";
    }
    if(nelua_unlikely(s.data[s.size]) != 0) {
      nelua_panic_cstring("attempt to convert a non null terminated string to cstring");
    }
    return (char*)s.data;
  }
nlmulret_nelua_filestream_nlstring_nlint64 nelua_filestream_open_1(nlstring filename, nlstring mode) {
  nelua_assert_line_47(nelua_checkmode(mode), ((nlstring){(uint8_t*)"invalid mode", 12}));
  FILE_ptr fp = fopen(nelua_assert_string2cstring(filename), nelua_assert_string2cstring(mode));
  if((!(fp != NULL))) {
    nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
    _mulret_1.r1 = (nelua_filestream){0};
    _mulret_1.r2 = nelua_cstring2string(strerror(errno));
    _mulret_1.r3 = (int64_t)errno;
    return _mulret_1;
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_2;
  _mulret_2.r1 = nelua_filestream__fromfp(fp, fclose);
  _mulret_2.r2 = ((nlstring){(uint8_t*)"", 0});
  _mulret_2.r3 = 0;
  return _mulret_2;
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_close(nelua_filestream_ptr self) {
  nelua_FStream_ptr fs = self->fs;
  if(((!(fs != NULL)) || (!(fs->fp != NULL)))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  if((((fs->fp == stdout) || (fs->fp == stderr)) || (fs->fp == stdin))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"cannot close standard file", 26}), -1};
  }
  errno = 0;
  int res = 0;
  if((fs->closef != NULL)) {
    res = fs->closef(fs->fp);
  }
  self->fs->fp = ((FILE_ptr)NULL);
  self->fs->closef = (function_58d7Pdou2YVLfzmgT)NULL;
  nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
  nlmulret_nlboolean_nlstring_nlint64 _ret_1 = nelua_fileresult((res == 0));
  _mulret_1.r1 = _ret_1.r1;
  _mulret_1.r2 = _ret_1.r2;
  _mulret_1.r3 = _ret_1.r3;
  return _mulret_1;
}
bool nelua_eq_nlcint_nluint8(int a, uint8_t b){
  return (uint32_t)a == (uint32_t)b && a >= 0;
}
nlmulret_nlboolean_nlstring nelua_readline(nelua_stringbuilderT_ptr sb, FILE_ptr fp, bool chop) {
  int c = 0;
  while(1) {
    uint32_t nr = (uint32_t)0U;
    nelua_span_uint8_ buff = nelua_stringbuilderT_prepare(sb, 1024U);
    if(nelua_span_uint8__empty((&buff))) {
      return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
    }
    while((nr < 1024)) {
      c = fgetc(fp);
      if(((c == EOF) || nelua_eq_nlcint_nluint8(c, 10U))) {
        break;
      }
      (*(uint8_t*)nelua_assert_deref(nelua_span_uint8____atindex((&buff), (uintptr_t)nr))) = (uint8_t)c;
      nr = (nr + 1);
    }
    nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
    if(((c == EOF) || nelua_eq_nlcint_nluint8(c, 10U))) {
      break;
    }
  }
  if(((!chop) && nelua_eq_nlcint_nluint8(c, 10U))) {
    if((!nelua_stringbuilderT_writebyte_1(sb, (uint8_t)c, NLNIL))) {
      return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
    }
  }
  return (nlmulret_nlboolean_nlstring){(nelua_eq_nlcint_nluint8(c, 10U) || (sb->size > 0)), (nlstring){0}};
}
nlmulret_nlboolean_nlstring nelua_readall(nelua_stringbuilderT_ptr sb, FILE_ptr fp) {
  while(1) {
    nelua_span_uint8_ p = nelua_stringbuilderT_prepare(sb, 1024U);
    if(nelua_span_uint8__empty((&p))) {
      return (nlmulret_nlboolean_nlstring){false, ((nlstring){(uint8_t*)"out of buffer memory", 20})};
    }
    size_t nr = fread((void*)p.data, (size_t)1U, 1024U, fp);
    nelua_stringbuilderT_commit(sb, (uintptr_t)nr);
    if((nr < 1024)) {
      break;
    }
  }
  return (nlmulret_nlboolean_nlstring){true, (nlstring){0}};
}
void nelua_panic_string(nlstring s){
  if(s.size > 0) {
    fwrite(s.data, 1, s.size, stderr);
    fputc('\n', stderr);
  }
  nelua_abort();
}
nlmulret_nlstring_nlstring_nlint64 nelua_filestream_read_1(nelua_filestream_ptr self, nlstring fmt) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlstring_nlstring_nlint64){(nlstring){0}, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nelua_stringbuilderT sb = {0};
  bool success = false;
  nlstring errmsg = {0};
  clearerr(fp);
  uint8_t c = fmt.data[0];
  if((c == 42U)) {
    c = fmt.data[1];
  }
  if((c == 108U)) {
    nlmulret_nlboolean_nlstring _asgnret_1 = nelua_readline((&sb), fp, true);
    success = _asgnret_1.r1;
    errmsg = _asgnret_1.r2;
  } else if((c == 76U)) {
    nlmulret_nlboolean_nlstring _asgnret_2 = nelua_readline((&sb), fp, false);
    success = _asgnret_2.r1;
    errmsg = _asgnret_2.r2;
  } else if((c == 97U)) {
    nlmulret_nlboolean_nlstring _asgnret_3 = nelua_readall((&sb), fp);
    success = _asgnret_3.r1;
    errmsg = _asgnret_3.r2;
  } else {
    nelua_panic_string(((nlstring){(uint8_t*)"invalid format", 14}));
  }
  int64_t status = 0;
  if((ferror(fp) != 0)) {
    nlmulret_nlboolean_nlstring_nlint64 _asgnret_4 = nelua_fileresult(false);
    success = _asgnret_4.r1;
    errmsg = _asgnret_4.r2;
    status = _asgnret_4.r3;
  }
  nlstring s = {0};
  if(success) {
    s = nelua_stringbuilderT_promote((&sb));
  } else {
    if((nelua_nlstring___len(errmsg) == 0)) {
      errmsg = ((nlstring){(uint8_t*)"eof", 3});
      status = (int64_t)EOF;
    } else if((status == 0)) {
      status = -1;
    }
    nelua_stringbuilderT_destroy((&sb));
  }
  return (nlmulret_nlstring_nlstring_nlint64){s, errmsg, status};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_1(nelua_filestream_ptr self, nlstring __arg1) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nlstring s = {0};
  s = __arg1;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
      nlmulret_nlboolean_nlstring_nlint64 _ret_1 = nelua_fileresult(false);
      _mulret_1.r1 = _ret_1.r1;
      _mulret_1.r2 = _ret_1.r2;
      _mulret_1.r3 = _ret_1.r3;
      return _mulret_1;
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_2(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2, nlstring __arg3) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nlstring s = {0};
  s = __arg1;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
      nlmulret_nlboolean_nlstring_nlint64 _ret_1 = nelua_fileresult(false);
      _mulret_1.r1 = _ret_1.r1;
      _mulret_1.r2 = _ret_1.r2;
      _mulret_1.r3 = _ret_1.r3;
      return _mulret_1;
    }
  }
  s = __arg2;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      nlmulret_nlboolean_nlstring_nlint64 _ret_2 = nelua_fileresult(false);
      _mulret_2.r1 = _ret_2.r1;
      _mulret_2.r2 = _ret_2.r2;
      _mulret_2.r3 = _ret_2.r3;
      return _mulret_2;
    }
  }
  s = __arg3;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_3;
      nlmulret_nlboolean_nlstring_nlint64 _ret_3 = nelua_fileresult(false);
      _mulret_3.r1 = _ret_3.r1;
      _mulret_3.r2 = _ret_3.r2;
      _mulret_3.r3 = _ret_3.r3;
      return _mulret_3;
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nlboolean_nlstring_nlint64 nelua_filestream_write_3(nelua_filestream_ptr self, nlstring __arg1, nlstring __arg2) {
  FILE_ptr fp = nelua_filestream__getfp(self);
  if((!(fp != NULL))) {
    return (nlmulret_nlboolean_nlstring_nlint64){false, ((nlstring){(uint8_t*)"attempt to use a closed file", 28}), -1};
  }
  nlstring s = {0};
  s = __arg1;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_1;
      nlmulret_nlboolean_nlstring_nlint64 _ret_1 = nelua_fileresult(false);
      _mulret_1.r1 = _ret_1.r1;
      _mulret_1.r2 = _ret_1.r2;
      _mulret_1.r3 = _ret_1.r3;
      return _mulret_1;
    }
  }
  s = __arg2;
  if((s.size > 0)) {
    bool ok = (fwrite((void*)s.data, (size_t)1U, (size_t)s.size, fp) == s.size);
    if((!ok)) {
      nlmulret_nlboolean_nlstring_nlint64 _mulret_2;
      nlmulret_nlboolean_nlstring_nlint64 _ret_2 = nelua_fileresult(false);
      _mulret_2.r1 = _ret_2.r1;
      _mulret_2.r2 = _ret_2.r2;
      _mulret_2.r3 = _ret_2.r3;
      return _mulret_2;
    }
  }
  return (nlmulret_nlboolean_nlstring_nlint64){true, ((nlstring){(uint8_t*)"", 0}), 0};
}
nlmulret_nelua_filestream_nlstring_nlint64 nelua_io_open_1(nlstring filename, nlstring mode) {
  nlmulret_nelua_filestream_nlstring_nlint64 _mulret_1;
  nlmulret_nelua_filestream_nlstring_nlint64 _ret_1 = nelua_filestream_open_1(filename, mode);
  _mulret_1.r1 = _ret_1.r1;
  _mulret_1.r2 = _ret_1.r2;
  _mulret_1.r3 = _ret_1.r3;
  return _mulret_1;
}
int nelua_assert_narrow_nlint64_nlcint(int64_t x){
  if(nelua_unlikely(x > 0x7fffffff || x < -2147483648)) {
    nelua_panic_cstring("narrow casting from int64 to cint failed");
  }
  return x;
}
void nelua_os_exit_1(int64_t code) {
  exit(nelua_assert_narrow_nlint64_nlcint(code));
}
uint64_t nelua_shl_nluint64(uint64_t a, int64_t b){
  if(nelua_likely(b >= 0 && b < 64)) return (uint64_t)a << b;
  else if(nelua_unlikely(b < 0 && b > -64)) return (uint64_t)a >> -b;
  else return 0;
}
uint64_t nelua_shr_nluint64(uint64_t a, int64_t b){
  if(nelua_likely(b >= 0 && b < 64)) return (uint64_t)a >> b;
  else if(nelua_unlikely(b < 0 && b > -64)) return (uint64_t)a << -b;
  else return 0;
}
uint64_t nelua_rotl(uint64_t x, int32_t n) {
  return (nelua_shl_nluint64(x, n) | nelua_shr_nluint64(x, (64 - n)));
}
uint64_t nelua_Xoshiro256_nextrand(nelua_Xoshiro256_ptr self) {
  nluint64_arr4 state = (nluint64_arr4){{(*(nluint64_arr4*)self->state).v[0], (*(nluint64_arr4*)self->state).v[1], ((*(nluint64_arr4*)self->state).v[2] ^ (*(nluint64_arr4*)self->state).v[0]), ((*(nluint64_arr4*)self->state).v[3] ^ (*(nluint64_arr4*)self->state).v[1])}};
  uint64_t res = (nelua_rotl((state.v[1] * 5), 7) * 9);
  (*(nluint64_arr4*)self->state).v[0] = (state.v[0] ^ state.v[3]);
  (*(nluint64_arr4*)self->state).v[1] = (state.v[1] ^ state.v[2]);
  (*(nluint64_arr4*)self->state).v[2] = (state.v[2] ^ (state.v[1] << 17));
  (*(nluint64_arr4*)self->state).v[3] = nelua_rotl(state.v[3], 45);
  return res;
}
double nelua_Xoshiro256_random(nelua_Xoshiro256_ptr self) {
  uint64_t rv = nelua_Xoshiro256_nextrand(self);
  return ((rv >> 11) / (double)9007199254740992U);
}
void nelua_Xoshiro256_seed(nelua_Xoshiro256_ptr self, uint64_t a, uint64_t b) {
  (*(nluint64_arr4*)self->state).v[0] = a;
  (*(nluint64_arr4*)self->state).v[1] = (uint64_t)0xffU;
  (*(nluint64_arr4*)self->state).v[2] = b;
  (*(nluint64_arr4*)self->state).v[3] = (uint64_t)0U;
  for(int64_t i = 0; i < 16; i = i + 1) {
    nelua_Xoshiro256_nextrand(self);
  }
}
nlmulret_nlint64_nlint64 nelua_math_randomseed_1(nlniltype x, nlniltype y) {
  int64_t x_1 = (int64_t)time((time_t_ptr)NULL);
  int64_t y_1 = (int64_t)(&x_1);
  nelua_Xoshiro256_seed((&nelua_default_random), (uint64_t)x_1, (uint64_t)y_1);
  return (nlmulret_nlint64_nlint64){x_1, y_1};
}
void nelua_assert_line_48(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/math.nelua\033[1m:540:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(low == m and up == n, \"number has no integer representation\")\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~\033[0m\n", 1, 130, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_49(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/math.nelua\033[1m:541:15: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(low <= up, \"interval is empty\")\n              \033[1m\033[32m^\033[0m\033[35m~~~~\033[0m\n", 1, 89, stderr);
    nelua_abort();
  }
}
void nelua_assert_line_50(bool cond, nlstring msg){
  if(nelua_unlikely(!cond)) {
    fwrite("/usr/local/lib/nelua/lib/math.nelua\033[1m:542:20: \033[31m\033[1mruntime error: \033[0m\033[1m", 1, 80, stderr);
    fwrite(msg.data, msg.size, 1, stderr);
    fwrite("\033[0m\n    check(low >= 0 or up < math.maxinteger + low, \"interval too large\")\n                   \033[1m\033[32m^\033[0m\033[35m~~~~~~~~~~~~~~~~~~~~~~~~~~~~\033[0m\n", 1, 148, stderr);
    nelua_abort();
  }
}
int64_t nelua_math_random_1(int64_t m, int64_t n) {
  double r = nelua_Xoshiro256_random((&nelua_default_random));
  int64_t low = m;
  int64_t up = n;
  nelua_assert_line_48(((low == m) && (up == n)), ((nlstring){(uint8_t*)"number has no integer representation", 36}));
  nelua_assert_line_49((low <= up), ((nlstring){(uint8_t*)"interval is empty", 17}));
  nelua_assert_line_50(((low >= 0) || (up < (9223372036854775807 + low))), ((nlstring){(uint8_t*)"interval too large", 18}));
  r = (r * ((double)(up - low) + 1.0));
  return ((int64_t)r + low);
}
int64_t parser_pure_line___len(parser_pure_line_ptr self) {
  return self->len;
}
int64_t nelua_assert_bounds_nlint64(int64_t index, uintptr_t len){
  if(nelua_unlikely((uintptr_t)index >= len || index < 0)) {
    nelua_panic_cstring("array index: position out of bounds");
  }
  return index;
}
nlstring parser_pure_line___index(parser_pure_line_ptr self, int64_t i) {
  return (*(nlstring_arr50*)self->content).v[nelua_assert_bounds_nlint64(i, 50)];
}
intptr_t parser_pure_file___len(parser_pure_file_ptr self) {
  return nelua_vector_pure_line____len((&self->content));
}
parser_pure_line parser_pure_file___index(parser_pure_file_ptr self, int64_t i) {
  return (*(parser_pure_line*)nelua_assert_deref(nelua_vector_pure_line____atindex((&self->content), nelua_assert_narrow_nlint64_nlusize(i))));
}
bool parser_is_whitespace_or_coma(nlstring s) {
  uint8_t c = nelua_nlstring_byte_1(s, NLNIL);
  return ((!((c > 0x20) && (c < 0x7f))) || (c == nelua_nlstring_byte_1(((nlstring){(uint8_t*)",", 1}), NLNIL)));
}
parser_pure_line parser_purify_line(nlstring s) {
  bool in_word = false;
  parser_pure_line ret = {0};
  ret.len = 0;
  int64_t pointer_1 = 1;
  int64_t curr_word_start = 0;
  while(((pointer_1 <= nelua_nlstring___len(s)) && (parser_pure_line___len((&ret)) < 49))) {
    nlstring curr_char = nelua_nlstring_sub_1(s, (intptr_t)pointer_1, (intptr_t)pointer_1);
    if(nelua_nlstring___eq(curr_char, ((nlstring){(uint8_t*)";", 1}))) {
      break;
    }
    if(in_word) {
      if(parser_is_whitespace_or_coma(curr_char)) {
        ret.content[nelua_assert_bounds_nlint64(parser_pure_line___len((&ret)), 50)] = nelua_nlstring_sub_1(s, (intptr_t)curr_word_start, (intptr_t)(pointer_1 - 1));
        ret.len = (parser_pure_line___len((&ret)) + 1);
        in_word = false;
      }
    } else {
      if((!parser_is_whitespace_or_coma(curr_char))) {
        in_word = true;
        curr_word_start = pointer_1;
      }
    }
    pointer_1 = (pointer_1 + 1);
  }
  if(in_word) {
    ret.content[nelua_assert_bounds_nlint64(parser_pure_line___len((&ret)), 50)] = nelua_nlstring_sub_1(s, (intptr_t)curr_word_start, (intptr_t)(pointer_1 - 1));
    ret.len = (parser_pure_line___len((&ret)) + 1);
  }
  return ret;
}
parser_pure_file parser_purify_string(nlstring s) {
  parser_pure_file ret = {0};
  intptr_t line_start = 1;
  for(intptr_t i = 1, _end = nelua_nlstring___len(s); i <= _end; i = i + 1) {
    if(nelua_nlstring___eq(nelua_nlstring_sub_1(s, i, i), ((nlstring){(uint8_t*)"\n", 1}))) {
      if(((i - 1) >= line_start)) {
        nelua_vector_pure_line__push((&ret.content), parser_purify_line(nelua_nlstring_sub_1(s, line_start, (i - 1))));
      } else {
        nelua_vector_pure_line__push((&ret.content), parser_purify_line(((nlstring){(uint8_t*)"", 0})));
      }
      line_start = (i + 1);
    }
  }
  if((nelua_nlstring___len(s) >= line_start)) {
    nelua_vector_pure_line__push((&ret.content), parser_purify_line(nelua_nlstring_sub_1(s, line_start, nelua_nlstring___len(s))));
  }
  return ret;
}
parser_pure_file parser_purify_file(nelua_filestream file) {
  nlstring s = nelua_filestream_read_1((&file), ((nlstring){(uint8_t*)"a", 1})).r1;
  nelua_filestream_close((&file));
  return parser_purify_string(s);
}
nlmulret_nelua_vector_line_content__driver_helper_error_t driver_helper_decode_input(parser_pure_file input) {
  nelua_vector_line_content_ ret = {0};
  if((parser_pure_file___len((&input)) == 0)) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, empty input file.\n", 25}));
    return (nlmulret_nelua_vector_line_content__driver_helper_error_t){ret, 1};
  }
  parser_pure_line colum_header = parser_pure_file___index((&input), 0);
  if((parser_pure_line___len((&colum_header)) < 4)) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, not enought columns in input file.\n", 42}));
    return (nlmulret_nelua_vector_line_content__driver_helper_error_t){ret, 1};
  }
  int64_t name_col = 0;
  int64_t addr_col = 0;
  int64_t off_col = 0;
  int64_t size_col = 0;
  for(int64_t i = 0; i < 4; i = i + 1) {
    if(nelua_nlstring___eq(nelua_nlstring_lower(parser_pure_line___index((&colum_header), i)), ((nlstring){(uint8_t*)"name", 4}))) {
      name_col = (i + 1);
    } else if(nelua_nlstring___eq(nelua_nlstring_lower(parser_pure_line___index((&colum_header), i)), ((nlstring){(uint8_t*)"address", 7}))) {
      addr_col = (i + 1);
    } else if(nelua_nlstring___eq(nelua_nlstring_lower(parser_pure_line___index((&colum_header), i)), ((nlstring){(uint8_t*)"offset", 6}))) {
      off_col = (i + 1);
    } else if(nelua_nlstring___eq(nelua_nlstring_lower(parser_pure_line___index((&colum_header), i)), ((nlstring){(uint8_t*)"size", 4}))) {
      size_col = (i + 1);
    }
  }
  if(((((name_col == 0) || (addr_col == 0)) || (size_col == 0)) || (off_col == 0))) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, missing correct title for at least one of the columns.", 61}));
    return (nlmulret_nelua_vector_line_content__driver_helper_error_t){ret, 1};
  }
  for(intptr_t i = 1, _end = parser_pure_file___len((&input)); i < _end; i = i + 1) {
    parser_pure_line curr_line = parser_pure_file___index((&input), (int64_t)i);
    if((parser_pure_line___len((&curr_line)) == 0)) {
      continue;
    }
    if((parser_pure_line___len((&curr_line)) < 4)) {
      nelua_filestream_write_2((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, missing column in line ", 30}), nelua_tostring_1((i + 1)), ((nlstring){(uint8_t*)".\n", 2}));
      return (nlmulret_nelua_vector_line_content__driver_helper_error_t){ret, 1};
    }
    driver_helper_line_content new_line = {0};
    new_line.name = parser_pure_line___index((&curr_line), (name_col - 1));
    new_line.address = nelua_tointeger_1(parser_pure_line___index((&curr_line), (addr_col - 1)), 16);
    new_line.offset = nelua_tointeger_1(parser_pure_line___index((&curr_line), (off_col - 1)), 10);
    new_line.size = nelua_tointeger_1(parser_pure_line___index((&curr_line), (size_col - 1)), 10);
    nelua_vector_line_content__push((&ret), new_line);
  }
  return (nlmulret_nelua_vector_line_content__driver_helper_error_t){ret, 0};
}
nlstring driver_helper_format_field(driver_helper_line_content field) {
  nelua_stringbuilderT builder = {0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"#define ", 8}));
  nelua_stringbuilderT_write_1((&builder), field.name);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"_ADDR   0x", 10}));
  nelua_stringbuilderT_write_1((&builder), nelua_nlstring_format_2(((nlstring){(uint8_t*)"%X", 2}), field.address));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"#define ", 8}));
  nelua_stringbuilderT_write_1((&builder), field.name);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"_OFFSET ", 8}));
  nelua_stringbuilderT_write_1((&builder), nelua_nlstring_format_2(((nlstring){(uint8_t*)"%i", 2}), field.offset));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"#define ", 8}));
  nelua_stringbuilderT_write_1((&builder), field.name);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"_SIZE   ", 8}));
  nelua_stringbuilderT_write_1((&builder), nelua_nlstring_format_2(((nlstring){(uint8_t*)"%i", 2}), field.size));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n\n", 2}));
  return nelua_stringbuilderT_promote((&builder));
}
nlstring driver_helper_add_include_guard(nlstring header) {
  nelua_math_randomseed_1(NLNIL, NLNIL);
  nlstring guard_macro = nelua_nlstring_format_2(((nlstring){(uint8_t*)"__GENERATED_HEADER_%X__", 23}), nelua_math_random_1(0, 0xffffffff));
  nelua_stringbuilderT builder = {0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"#ifndef ", 8}));
  nelua_stringbuilderT_write_1((&builder), guard_macro);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n", 1}));
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"#define ", 8}));
  nelua_stringbuilderT_write_1((&builder), guard_macro);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n\n", 2}));
  nelua_stringbuilderT_write_1((&builder), header);
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)"\n#endif\n\n", 9}));
  return nelua_stringbuilderT_promote((&builder));
}
uintptr_t nelua_assert_narrow_nlisize_nlusize(intptr_t x){
  if(nelua_unlikely(x < 0)) {
    nelua_panic_cstring("narrow casting from isize to usize failed");
  }
  return x;
}
nlstring driver_helper_make_header(nelua_vector_line_content_ csv) {
  nelua_stringbuilderT builder = {0};
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)nelua_strlit_1, 693}));
  for(intptr_t i = 0, _end = nelua_vector_line_content____len((&csv)); i < _end; i = i + 1) {
    nelua_stringbuilderT_write_1((&builder), driver_helper_format_field((*(driver_helper_line_content*)nelua_assert_deref(nelua_vector_line_content____atindex((&csv), nelua_assert_narrow_nlisize_nlusize(i))))));
  }
  nelua_stringbuilderT_write_1((&builder), ((nlstring){(uint8_t*)nelua_strlit_2, 1297}));
  nlstring raw_header = nelua_stringbuilderT_promote((&builder));
  return driver_helper_add_include_guard(raw_header);
}
void nelua_print_1(nlstring a1) {
  if(a1.size > 0) {
    fwrite(a1.data, 1, a1.size, stdout);
  }
  fputc('\n', stdout);
  fflush(stdout);
}
int64_t driver_helper_main() {
  if((nelua_sequence_string__1___len((&nelua_arg)) == 0)) {
    nelua_print_1(((nlstring){(uint8_t*)nelua_strlit_3, 337}));
    return 0;
  }
  if(((((nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 1U))), ((nlstring){(uint8_t*)"--help", 6})) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 1U))), ((nlstring){(uint8_t*)"-help", 5}))) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 1U))), ((nlstring){(uint8_t*)"-h", 2}))) || nelua_nlstring___eq((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 1U))), ((nlstring){(uint8_t*)"help", 4}))) && (nelua_sequence_string__1___len((&nelua_arg)) == 1))) {
    nelua_print_1(((nlstring){(uint8_t*)nelua_strlit_3, 337}));
    return 0;
  }
  if((nelua_sequence_string__1___len((&nelua_arg)) != 2)) {
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"Error, invalid arguments.\n", 26}));
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)nelua_strlit_3, 337}));
    nelua_filestream_write_1((&nelua_io_stderr), ((nlstring){(uint8_t*)"\n", 1}));
    return 4;
  }
  nlmulret_nelua_filestream_nlstring_nlint64 _asgnret_1 = nelua_io_open_1((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 1U))), ((nlstring){(uint8_t*)"r", 1}));
  nelua_filestream f_in = _asgnret_1.r1;
  nlstring err_msg = _asgnret_1.r2;
  int64_t err_code = _asgnret_1.r3;
  if((err_code != 0)) {
    nelua_filestream_write_3((&nelua_io_stderr), err_msg, ((nlstring){(uint8_t*)"\n", 1}));
    return err_code;
  }
  parser_pure_file pure = parser_purify_file(f_in);
  nlmulret_nelua_vector_line_content__driver_helper_error_t _asgnret_2 = driver_helper_decode_input(pure);
  nelua_vector_line_content_ decoded = _asgnret_2.r1;
  driver_helper_error_t err_code_1 = _asgnret_2.r2;
  if((err_code_1 != 0)) {
    return (int64_t)err_code_1;
  }
  nlstring header = driver_helper_make_header(decoded);
  nlmulret_nelua_filestream_nlstring_nlint64 _asgnret_3 = nelua_io_open_1((*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), 2U))), ((nlstring){(uint8_t*)"w", 1}));
  nelua_filestream f_out = _asgnret_3.r1;
  nlstring err_msg_1 = _asgnret_3.r2;
  int64_t err_code_2 = _asgnret_3.r3;
  if((err_code_2 != 0)) {
    nelua_filestream_write_3((&nelua_io_stderr), err_msg_1, ((nlstring){(uint8_t*)"\n", 1}));
    return err_code_2;
  }
  nelua_filestream_write_1((&f_out), header);
  nelua_filestream_close((&f_out));
  return 0;
}
int nelua_main(int nelua_argc, char** nelua_argv) {
  { /* require 'io' */
    nelua_stderrfs = (nelua_FStream){.fp = stderr};
    nelua_stdoutfs = (nelua_FStream){.fp = stdout};
    nelua_stdinfs = (nelua_FStream){.fp = stdin};
    nelua_io_stderr = (nelua_filestream){.fs = (&nelua_stderrfs)};
    nelua_io_stdout = (nelua_filestream){.fs = (&nelua_stdoutfs)};
    nelua_io_stdin = (nelua_filestream){.fs = (&nelua_stdinfs)};
  }
  { /* require 'arg' */
    if((nelua_argc > 0)) {
      uintptr_t narg = (uintptr_t)(nelua_argc - 1);
      nelua_sequence_string__1_reserve((&nelua_arg), narg);
      for(uintptr_t i = 0U, _end = narg; i <= _end; i = i + 1) {
        (*(nlstring*)nelua_assert_deref(nelua_sequence_string__1___atindex((&nelua_arg), i))) = nelua_cstring2string(nelua_argv[i]);
      }
    }
  }
  nelua_os_exit_1(driver_helper_main());
  return 0;
}
