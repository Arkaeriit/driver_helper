
require 'io'
require 'filestream'
require 'vector'
require 'parser'
require 'stringbuilder'

local error_t = @enum{
	OK = 0,
	format = 1,
	file_io = 2,
	content = 3,
}

--This is a data type to store the content of a line of csv file
local line_content = @record{
	name: string,
	address: integer,
	offset: integer,
	size: integer,
}

function line_content:__tostring()
   local builder: stringbuilder 
   builder:write("{ name = ")
   builder:write(self.name)
   builder:write(", address = ")
   builder:write(self.address)
   builder:write(", offset = ")
   builder:write(self.offset)
   builder:write(", size = ")
   builder:write(self.size)
   builder:write(" }\n")
   return builder:promote()
end

--Format a vector of lines to show the whole content of the cvs
local function print_csv(csv: vector(line_content)) --Note: semms to be bugged
   local builder: stringbuilder 
   builder:write("[\n")
   for i=0,<#csv do
	   builder:write(csv[i])
   end
   builder:write("]\n")
end

--Decode a pure_file into a list of line_content
local function decode_input(input: pure_file): (vector(line_content), error_t)
	local ret: vector(line_content)
	if #input == 0 then
		io.stderr:write("Error, empty input file.\n")
		return ret, error_t.format
	end
	local colum_header = input[0]
	print(colum_header)
	if #colum_header < 4 then
		io.stderr:write("Error, not enoughth columns in input file.\n")
		return ret, error_t.format
	end
	local name_col, addr_col, off_col, size_col: integer --Note, the column indexing will start as 1 to keep 0 as an error-detecting value
	for i=0,<4 do
		if colum_header[i] == "Name" then
			name_col = i+1
		elseif colum_header[i] == "Address" then
			addr_col = i+1
		elseif colum_header[i] == "Offset" then
			off_col = i+1
		elseif colum_header[i] == "Size" then
			size_col = i+1
		end
	end
	if name_col == 0 or addr_col == 0 or size_col == 0 or off_col == 0 then return ret, error_t.format end
	for i=1,<#input do
		local curr_line = input[i]
		if #curr_line == 0 then continue end
		if #curr_line < 4 then return ret, error_t.format end
		local new_line: line_content
		new_line.name = curr_line[name_col-1]
		new_line.address = tointeger(curr_line[addr_col-1], 16)
		new_line.offset = tointeger(curr_line[off_col-1], 10)
		new_line.size = tointeger(curr_line[size_col-1], 10)
		ret:push(new_line)
	end
	return ret, error_t.OK
end

--Generates the macros used to manipulate a field
local function format_field(field: line_content): string
   local builder: stringbuilder 
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_ADDR   0x")
   builder:write(string.format("%X", field.address))
   builder:write("\n")
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_OFFSET ")
   builder:write(string.format("%i", field.offset))
   builder:write("\n")
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_SIZE   ")
   builder:write(string.format("%i", field.size))
   builder:write("\n\n")
end

local macro_function_templates <comptime> = [[
//                       Macro used to manipulate fields                      //

#define SIZE_MASK(field_name) \
	( ( 1 << (field_name ## _SIZE)) - 1 )

#define FIELD_READ(field_name) \
	(
		(_register_read(field_name ## _ADDR)
		>> (field_name ## _OFFSET))
		& SIZE_MASK(field_name)
	)

#define POS_MASK(field_name) \
	( ~(SIZE_MASK(field_name) << field_name ## _OFFSET)  )

#define FIELD_WRITE(field_name, data) \
	_register_write(field_name ## _ADDR, 
		(POS_MASK(field_name) & _register_read(field_name ## _ADDR)) | //All the other fields of the register
		((data & SIZE_MASK(field_name)) << field_name ## _OFFSET))     //The data masked and offset to the correct field


]]

local test_f = io.open("../MAX30009_regs.csv")
local pure_csv = purify_file(test_f)
print(#pure_csv)
local ccccc = decode_input(pure_csv)
for i=1,<#ccccc do
	print(ccccc[i])
end

