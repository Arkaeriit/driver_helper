
require 'io'
require 'os'
require 'arg'
require 'math'
require 'vector'
require 'parser'
require 'filestream'
require 'stringbuilder'

local error_t = @enum{
	OK = 0,
	format = 1,
	file_io = 2,
	content = 3,
	arguments = 4,
}

--This is a data type to store the content of a line of csv file
local line_content = @record{
	name: string,
	address: integer,
	offset: integer,
	size: integer,
}

function line_content:__tostring()
   local builder: stringbuilder 
   builder:write("{ name = ")
   builder:write(self.name)
   builder:write(", address = ")
   builder:write(self.address)
   builder:write(", offset = ")
   builder:write(self.offset)
   builder:write(", size = ")
   builder:write(self.size)
   builder:write(" }\n")
   return builder:promote()
end

--Format a vector of lines to show the whole content of the csv
local function print_csv(csv: vector(line_content)) --Note: semms to be bugged
   local builder: stringbuilder 
   builder:write("[\n")
   for i=0,<#csv do
	   builder:write(csv[i])
   end
   builder:write("]\n")
end

--Decode a pure_file into a list of line_content
local function decode_input(input: pure_file): (vector(line_content), error_t)
	local ret: vector(line_content)
	if #input == 0 then
		io.stderr:write("Error, empty input file.\n")
		return ret, error_t.format
	end
	local colum_header = input[0]
	if #colum_header < 4 then
		io.stderr:write("Error, not enoughth columns in input file.\n")
		return ret, error_t.format
	end
	local name_col, addr_col, off_col, size_col: integer --Note, the column indexing will start as 1 to keep 0 as an error-detecting value
	for i=0,<4 do
		if colum_header[i] == "Name" then
			name_col = i+1
		elseif colum_header[i] == "Address" then
			addr_col = i+1
		elseif colum_header[i] == "Offset" then
			off_col = i+1
		elseif colum_header[i] == "Size" then
			size_col = i+1
		end
	end
	if name_col == 0 or addr_col == 0 or size_col == 0 or off_col == 0 then
		io.stderr:write("Error, missing correct title for at least one of the columns.")
		return ret, error_t.format
	end
	for i=1,<#input do
		local curr_line = input[i]
		if #curr_line == 0 then continue end
		if #curr_line < 4 then
			io.stderr:write("Error, missing column in line ", tostring(i+1), ".\n")
			return ret, error_t.format
		end
		local new_line: line_content
		new_line.name = curr_line[name_col-1]
		new_line.address = tointeger(curr_line[addr_col-1], 16)
		new_line.offset = tointeger(curr_line[off_col-1], 10)
		new_line.size = tointeger(curr_line[size_col-1], 10)
		ret:push(new_line)
	end
	return ret, error_t.OK
end

--Generates the macros used to manipulate a field
local function format_field(field: line_content): string
   local builder: stringbuilder 
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_ADDR   0x")
   builder:write(string.format("%X", field.address))
   builder:write("\n")
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_OFFSET ")
   builder:write(string.format("%i", field.offset))
   builder:write("\n")
   builder:write("#define ")
   builder:write(field.name)
   builder:write("_SIZE   ")
   builder:write(string.format("%i", field.size))
   builder:write("\n\n")
   return builder:promote()
end

local macro_function_templates <comptime> = [[
// --------------------- Macro used to manipulate fields -------------------- //

#define SIZE_MASK(field_name)             \
	( ( 1 << (field_name ## _SIZE)) - 1 )  

#define FIELD_READ(field_name)               \
	(                                        \
		(_register_read(field_name ## _ADDR) \
		>> (field_name ## _OFFSET))          \
		& SIZE_MASK(field_name)              \
	)                                         

#define POS_MASK(field_name)                               \
	( ~(SIZE_MASK(field_name) << field_name ## _OFFSET)  )  

#define FIELD_WRITE(field_name, data)                                  \
	_register_write(field_name ## _ADDR,                               \
		/* All the other fields of the register */                     \
		(POS_MASK(field_name) & _register_read(field_name ## _ADDR)) | \
		/* The data masked and offset to the correct field */          \
		((data & SIZE_MASK(field_name)) << field_name ## _OFFSET))      


]]

local file_start_template <comptime> = [[
// -------------------- User-defined functions to edit registers ------------ //

// Replace here with a function _register_read(addr) that reads the
// register at addres `addr`

// Replace here with a function _register_write(addr, data) that write `data`
// to the register at addres `addr`


// -------------------------- Info about all the fields --------------------- //

]]


--This functions takes as input a string that should be the content of a C
--header file and add include-guards to it
local function add_include_guard(header: string): string
	math.randomseed()
	local guard_macro = string.format("__GENERATED_HEADER_%X__", math.random(0, 0xFFFFFFFF))
	local builder: stringbuilder 
	builder:write("#ifndef ")
	builder:write(guard_macro)
	builder:write("\n")
	builder:write("#define ")
	builder:write(guard_macro)
	builder:write("\n\n")
	builder:write(header)
	builder:write("\n#endif\n\n")
	return builder:promote()
end

--This function taakes a vector of lines representing the data in the
--csv file and return the content of the generated header file
local function make_header(csv: vector(line_content)): string
	local builder: stringbuilder
	builder:write(file_start_template)
	for i=0,<#csv do
		builder:write(format_field(csv[i]))
	end
	builder:write(macro_function_templates)
	local raw_header = builder:promote()
	return add_include_guard(raw_header)
end

local help_message <comptime> = "coucou"

local function main(): integer
	--Reading args
	if #arg == 0 then 
		print(help_message)
		return 0
	end
	if (arg[1] == "--help" or arg[1] == "-help" or arg[1] == "-h" or arg[1] == "help") and #arg == 1 then
		print(help_message)
		return 0
	end
	if #arg ~= 2 then
		io.stderr:write("Error, invalid arguments.\n")
		io.stderr:write(help_message)
		io.stderr:write("\n")
		return error_t.arguments
	end
	--Reading input
	local f_in, err_msg, err_code = io.open(arg[1], "r")
	if err_code ~= 0 then
		io.stderr:write(err_msg, "\n")
		return err_code
	end
	local pure = purify_file(f_in)
	local decoded, err_code = decode_input(pure)
	if err_code ~= 0 then
		return err_code
	end
	local header = make_header(decoded)
	--Writing output
	local f_out, err_msg, err_code = io.open(arg[2], "w")
	if err_code ~= 0 then
		io.stderr:write(err_msg, "\n")
		return err_code
	end
	f_out:write(header)
	f_out:close()
	return 0
end

os.exit(main())

